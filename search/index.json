[{"content":"摘要 缘分，还有时机，不是自动找上门的偶然，是带着恳切的盼望做出的无数选择，创造的奇迹般的瞬间，毫不迟疑的放弃和当机立断，制造出了时机\n真正阻止你前进的，不是能力不足，不是环境严峻，而是你自我设限的内心。 别总说自己不行，说多了，你就真不行了。\n害怕拒绝——厚重而脆弱的自尊 那些改变世界的，改变人们生活方式和思维方式的，都是那些一开始就遭到拒绝的人。然而他们没有让拒绝定义自己，而是用被拒绝后的行动重新定义了自己。\n我以为你生性冷淡，直到看到你对他嘘寒问暖，我才明白，哪有生性冷淡的人，无非是没那么喜欢而已。 哪有那么多直男，就算是直男，遇见他真正喜欢的人，也会很温暖\n他不喜欢你，他就是令人崇拜的，高冷的；他喜欢你，他就是幼稚的温暖的\n穷不怪父，孝不比兄，苦不责妻，气不凶子\n到底何为命运？ 我特别喜欢心理学家荣格的一段解释—— 当你面对一件事情时，按照你过往的性格和逻辑做出的行为，就是命。 如果你做出不符合自己过往性格的行为，让自己的人生出现了偏差，这就是运。 所以命是定数，运是改变。 逆天改命逆的不是天，而是自己的本能。 如果你想拥有更好的人生，就要在重要的时刻，尽量理性地做出正确选择。 而不是顺从本能随波逐流。 更不是求那些野生大师来为你指明方向。\n除了饥饿与疾病，一切痛苦来自于价值观。\n作家马德有一句话说得很好：“那些天性里的爱好，支撑着我们度过生命里的荒芜。” 多一门爱好，就是让你对生活多一点期待，多一点对抗庸俗世界的力量。\n法国作家罗曼罗兰说过：“世界上只有一种真正的英雄主义，那就是认清生活的真相后依然热爱生活。” 表达了面对生活困境时要保持热爱与勇气的重要性。\n法国作家罗曼罗兰说过：“人生如奔流，没有暗礁，激不起美丽的浪花。” 这句话强调了逆境对于人生价值的重要性，只有经历挑战，才能成就非凡。\n法国作家罗曼罗兰说过：“宿命论是缺乏意志力的借口。” 我们应该反对宿命论，而是通过努力改变命运。\n","date":"2025-04-22T18:55:20-08:00","permalink":"https://pangfq.github.io/blog/p/essay-summary/","title":"美文摘要"},{"content":"概述 adb，是Android Debug Bridge，Android调试桥。\n其实就是Android提供的一个命令行工具，可以与设备进行通信，方便调试。\n工作原理 看着小小的adb工具，其实是一个C/S架构的程序，一共涉及到3个组件：\nClient：客户端，用于发送命令。就是在电脑上打开的终端窗口，输入adb命令，就是一个adb客户端了，我们可以打开多个窗口。 Server：服务端，用于接收命令并转发到设备。服务端在电脑上作为后台进程运行。 adbd：守护程序，用于在设备上运行命令。守护程序在每个设备上作为后台进程运行。 USB连接 USB连接调试，就是通过数据线连接，调试之前要去“开发者模式”中把“USB调试”打开。\nWIFI连接 没想到吧，还可以WIFI连接调试，但这个有点鸡肋，因为首先要用数据线连接，输入adb tcpip port 告诉设备打开一个端口建立一个TCP/IP连接，然后才能实现WIFI连接，问题是我手边有数据线还使用WIFI连接干啥？！（Android11以上的设备不需要先用数据线连接设置，可以直接到开发者模式下打开相关设置即可）\n另一个鸡肋的原因是，测试机我们不会专门给它充电，全靠上班连电脑开发时顺便充下电，所以WIFI连接用的很少，但也要知道可以实现WIFI连接调试。\n我们看下具体的操作过程（Android10及以下）：\n连接数据线 在终端输入adb tcpip 5555，表示通知设备开始监听5555端口的tcp/ip连接 拔掉数据线 找到设备ip地址 在终端输入adb connect 设备ip地址 断开连接：adb disconnect\n常用命令 查看设备 1 adb devices 安装应用 1 2 // -r 是replace的首字母，表示覆盖安装 adb install -r apk绝对路径 复制文件 1 2 3 4 5 // 表示从手机上把某个文件复制到电脑上 adb pull remote local // 表示从电脑上把某个文件复制到设备上 adb push local remote 停止adb服务器 1 2 3 // 如果发生一些异常情况，可以尝试停止服务器解决 adb kill-server // 杀掉adb服务器之后，随便在终端输入任意adb命令即可重新启动adb服务器 指定设备发送 1 2 3 4 5 6 7 $ adb devices List of devices attached emulator-5554 device emulator-5555 device // 通过-s指定设备序列号，即可发送命令到指定设备 $ adb -s emulator-5555 install helloWorld.apk 发送shell命令 1 2 3 4 5 6 7 // 有两种方式 // 1. 进入shell后直接使用shell命令 $ adb shell $\u0026gt;ls // 2. 不进入shell $ adb shell ls shell命令有很多，比如截屏、录制视频、启动activity、操作sqlite等等\n1 2 adb shell screencap /sdcard/screen.png // ... ","date":"2024-02-02T04:14:54-08:00","permalink":"https://pangfq.github.io/blog/p/android-adb/","title":"adb命令"},{"content":"概述 解压：复制并解压到data/app目录下； 校验签名； 解析AndroidManifest.xml：在data/data/目录下创建以应用包名命名的目录； 优化dex：Dalvik虚拟机会使用Dex2Opt工具对主dex优化成odex文件，其实就是将涉及到的依赖和dex打包到一起；如果是ART虚拟机将会扫描所有dex文件并转成oat机器码文件； 注册四大组件：将AndroidManifest.xml解析出的四大组件注册到PackageManagerService中，这样APP在启动某个四大组件时会通过跨进程通信到SystemServer进程中进行校验（PMS、AMS等各种MS都在SystemServer进程运行）； 最后发送安装完成的广播。 ","date":"2022-03-29T04:14:54-08:00","permalink":"https://pangfq.github.io/blog/p/android-apk_install/","title":"APK安装流程"},{"content":"概述 在APP的日常开发中，无论Android还是iOS，UI相关的需求都是非常多的，需求有大有小，比如小到改变字体颜色，大到自定义复杂的View，这些都离不开View的绘制，所以掌握绘制原理，是每个移动开发工程师的必备技能。\n思考 在阅读文章之前，先思考一个问题，带着问题去学习，效果会更好。\n我们在开发UI需求时，会在xml中写布局代码，这个xml最终会被Activity解析、加载、绘制出来，但具体是如何解析？如何加载？又是如何绘制的呢？这些过程涉及到了哪些方法，又涉及到了哪些对象呢？\n上述问题都将在这几篇系列文章中得到解答。\n源码 想要回答上面的问题，看源码是最好的方式。\n1 2 3 4 5 6 7 /** Activity.java **/ public void setContentView(@LayoutRes int layoutResID) { // 调用Window的setContentView()，而Window的唯一实现类是PhoneWindow getWindow().setContentView(layoutResID); // 初始化ActionBar initWindowDecorActionBar(); } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 /** PhoneWindow.java **/ // This is the view in which the window contents are placed. It is either // mDecor itself, or a child of mDecor where the contents go. // 翻译： // 这是一个在Window中用来替换成内容的View。可以是Decor自己，也可以是Decor的子View。 // 理解： // 1. 我们在xml中写的布局对于整个Activity来讲，叫content（这也是为什么Activity使用setContentView()来加载xml的原因），此处的mContentParent就是我们写的xml布局的直接父视图； // 2. 另外，mContentParent可能是DecorView(顶层视图)，也可能是DecorView的子视图，这个取决于给Window设置的feature属性，比如：android:theme=\u0026#34;@android:style/Theme.NoTitleBar\u0026#34;，全屏窗口，此时mContentParent就是DecorView； ViewGroup mContentParent; public void setContentView(int layoutResID) { // 如果mContentParent为空，则安装Decor。 // 1. mContentParent：content视图的直接父视图，可能是DecorView，也可能是DecorView的子视图 // 2. Decor：DecorView，顶层视图 if (mContentParent == null) { // 初始化DecorView和mContentParent installDecor(); } else if (!hasFeature(FEATURE_CONTENT_TRANSITIONS)) { mContentParent.removeAllViews(); } if (hasFeature(FEATURE_CONTENT_TRANSITIONS)) { final Scene newScene = Scene.getSceneForLayout(mContentParent, layoutResID, getContext()); transitionTo(newScene); } else { // 把content视图添加到mContentParent视图中 mLayoutInflater.inflate(layoutResID, mContentParent); } mContentParent.requestApplyInsets(); final Callback cb = getCallback(); if (cb != null \u0026amp;\u0026amp; !isDestroyed()) { cb.onContentChanged(); } mContentParentExplicitlySet = true; } private void installDecor() { if (mDecor == null) { // 生成DecorView mDecor = generateDecor(-1); // ... } else { mDecor.setWindow(this); } if (mContentParent == null) { // 生成mContentParent，并传入上面刚生成的DecorView实例，可见mContentParent依赖于mDecor mContentParent = generateLayout(mDecor); // ... } protected DecorView generateDecor(int featureId) { // ... // 直接new一个DecorView，其继承于FrameLayout，是Activity的顶层视图 return new DecorView(context, featureId, this, getAttributes()); } protected ViewGroup generateLayout(DecorView decor) { // ... int layoutResource; int features = getLocalFeatures(); // ... // 上面省略的代码是：通过判断feature类型来给layoutResource设置不同的系统布局，比如带ActionBar的，带TitleBar的，啥都不带的等 // ... // 把layoutResource的布局添加到DecorView中 mDecor.onResourcesLoaded(mLayoutInflater, layoutResource); // 调用DecorView的findViewById()，查找指定ID为com.android.internal.R.id.content的视图，这个视图就是mContentParent ViewGroup contentParent = (ViewGroup)findViewById(ID_ANDROID_CONTENT); // ... return contentParent; } public \u0026lt;T extends View\u0026gt; T findViewById(@IdRes int id) { // 调用的是DecorView的findViewById() return getDecorView().findViewById(id); } 流程总结 Activity的setContentView()内部调用的是PhoneWindow的setContentView() 先创建一个DecorView，其继承于FrameLayout，这是Activity的顶层视图 再根据Window设置的feature属性给DecorView选择添加对应的子布局，有带ActionBar，有不带ActionBar的等等 接着调用DecorView的findViewById(android.R.id.content)找到加载Content的父视图mContentParent 最后调用LayoutInflate.inflate(content, mContentParent)将content视图添加到mContentParent上 布局结构 上面是DecorView完整的组成，其中注意DecorView的两个子视图中有一个是状态栏，我们在源码追踪中没有说明，具体是在DecorView的updateColorViewInt()方法中创建并添加的。\n另外一个子视图就是根据不同feature属性选择inflate的布局，在这些布局中会有一个固定id为android.R.id.content的FrameLayout，也就是mContentParent，用来添加我们自己写的xml布局。\n总结 所以setContentView()只是解析xml创建View并设置到DecorView中，并没有进行绘制，所以绘制的代码我们还需要再找。\n关键词 DecorView 根据不同的feature属性inflate不同的布局 android.R.id.content是一个FrameLayout ","date":"2022-03-28T04:14:54-08:00","permalink":"https://pangfq.github.io/blog/p/android-view-source1/","title":"Activity绘制系列：1. setContentView()"},{"content":"概述 postInvalidate()和invalidate()的区别只有一个，就是postInvalidate()可以在子线程中进行调用刷新视图，因为其内部会通过主线程的Handler去处理调用，源码就不看了，比较简单，看名字也能大概猜到。\n总结 这里把requestLayout()、invalidate()、postInvalidate()三个方法放在一块儿总结下：\n如果想要重新测量、布局、绘制，则调用requestLayout()，但不要频繁调用；\n如果只想重新绘制，并且在主线程，则调用invalidate()，如果在子线程，则调用postInvalidate()，要比调用requestLayout()更高效。\n","date":"2022-03-28T04:14:54-08:00","permalink":"https://pangfq.github.io/blog/p/android-view-source10/","title":"Activity绘制系列：10. postInvalidate()"},{"content":"概述 在Activity中，我们知道，是通过findViewById()方法找到对应id的View实例，但内部是如何查找的呢？\n源码 Activity的内部会调用Window的findViewById()，而Window内部又会调用DecorView的findViewById()，而DecorView是一个FrameLayout，所以最终调用的是ViewGroup的findViewById()；\nfindViewById()内部又会调用findViewTraversal()，该方法在ViewGroup和View中是两种不同的实现：\nView中是直接判断要查找的id是否是自己的id，如果是则返回自身，如果不是则返回null；\nViewGroup中是通过一个for循环，遍历自己所有的子View，并调用各自的findViewById()；\n综上所述，Activity的findViewById()其实就是树的深度优先遍历操作，时间复杂度为O(n)，快慢取决于View的个数和位置，是一个效率比较低的操作。\n以下是源码分析：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 // 该方法定义在View中 public final \u0026lt;T extends View\u0026gt; T findViewById(@IdRes int id) { // 这个NO_ID = -1 if (id == NO_ID) { return null; } // 另外调用findViewTraversal()方法，看方法名称就知道是通过遍历的方式 return findViewTraversal(id); } // 这是View中的findViewTraversal()方法，因为是View，所以只判断了自己的id protected \u0026lt;T extends View\u0026gt; T findViewTraversal(@IdRes int id) { if (id == mID) { return (T) this; } return null; } // 这是ViewGroup中的findViewTraversal()方法 protected \u0026lt;T extends View\u0026gt; T findViewTraversal(@IdRes int id) { if (id == mID) { return (T) this; } final View[] where = mChildren; final int len = mChildrenCount; // 可以看到，是通过一个for循环遍历自己的所有子View实现的 for (int i = 0; i \u0026lt; len; i++) { View v = where[i]; if ((v.mPrivateFlags \u0026amp; PFLAG_IS_ROOT_NAMESPACE) == 0) { // 继续调用View或者ViewGroup的findViewById() v = v.findViewById(id); // 如果不为空，则说明找到了 if (v != null) { return (T) v; } } } // 循环正常结束，则说明没找到，则返回null return null; } 总结 xml布局在经过setContentView()之后，会以View树的形式加载到内存，所以findViewById()查找指定id的View，其实就是在树的的所有结点中查找，也就是树的遍历，并且是深度优先遍历。\n关键词 View树 树的深度优先遍历 ","date":"2022-03-28T04:14:54-08:00","permalink":"https://pangfq.github.io/blog/p/android-view-source2/","title":"Activity绘制系列：2. findViewById()"},{"content":"概述 我们知道，在Activity的setContentView()中，还有ListView的Adapter中，都是调用LayoutInflater.inflate()方法将xml布局渲染成View视图的，但具体是如何渲染的呢？我们来看下它的源码。\n源码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 /** LayoutInflater.java **/ public View inflate(@LayoutRes int resource, @Nullable ViewGroup root) { return inflate(resource, root, root != null); } public View inflate(@LayoutRes int resource, @Nullable ViewGroup root, boolean attachToRoot) { final Resources res = getContext().getResources(); if (DEBUG) { Log.d(TAG, \u0026#34;INFLATING from resource: \\\u0026#34;\u0026#34; + res.getResourceName(resource) + \u0026#34;\\\u0026#34; (\u0026#34; + Integer.toHexString(resource) + \u0026#34;)\u0026#34;); } View view = tryInflatePrecompiled(resource, res, root, attachToRoot); if (view != null) { return view; } // 得到一个xml资源解析器 XmlResourceParser parser = res.getLayout(resource); try { // 将解析器传入inflate()方法中 return inflate(parser, root, attachToRoot); } finally { // 这个解析器看来比较占资源 parser.close(); } } 1 2 3 4 5 6 7 8 9 10 /**XmlResourceParser.java**/ // xml资源解析器是一个接口，并且继承于XmlPullParser接口，也就是Android的Pull解析，跟SAX类似 public interface XmlResourceParser extends XmlPullParser, AttributeSet, AutoCloseable { String getAttributeNamespace (int index); /** * Close this parser. Calls on the interface are no longer valid after this call. */ public void close(); } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 public View inflate(XmlPullParser parser, @Nullable ViewGroup root, boolean attachToRoot) { synchronized (mConstructorArgs) { // ... try { // ... // \u0026lt;merge/\u0026gt;标签的解析代码 if (TAG_MERGE.equals(name)) { if (root == null || !attachToRoot) { throw new InflateException(\u0026#34;\u0026lt;merge /\u0026gt; can be used only with a valid \u0026#34; + \u0026#34;ViewGroup root and attachToRoot=true\u0026#34;); } rInflate(parser, root, inflaterContext, attrs, false); } else { // Temp is the root view that was found in the xml // 根据标签名称创建View，并赋值给命名为temp的临时变量 final View temp = createViewFromTag(root, name, inflaterContext, attrs); // ... // Inflate all children under temp against its context. // 开始解析子View rInflateChildren(parser, temp, attrs, true); if (DEBUG) { System.out.println(\u0026#34;-----\u0026gt; done inflating children\u0026#34;); } // We are supposed to attach all the views we found (int temp) // to root. Do that now. // 如果root参数不为空，并且attachToRoot为真，则将上面生成的View temp添加到root视图中 if (root != null \u0026amp;\u0026amp; attachToRoot) { root.addView(temp, params); } // Decide whether to return the root that was passed in or the // top view found in xml. // 如果root为空，或attachToRoot为假，则直接将View temp当成结果返回 if (root == null || !attachToRoot) { result = temp; } } } catch (XmlPullParserException e) { // ... } catch (Exception e) { // ... } finally { // ... } return result; } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 View createViewFromTag(View parent, String name, Context context, AttributeSet attrs, boolean ignoreThemeAttr) { // ... try { // 自定义流程 // 尝试创建View，这个方法内部会调用Factory、Factory2来尝试创建，如果用户实现了的话 // Factory是LayoutInflater对外提供的自定义解析xml的接口，比如想自定义一个标签名进行解析就可以实现Factory接口自己解析即可 View view = tryCreateView(parent, name, context, attrs); if (view == null) { final Object lastContext = mConstructorArgs[0]; mConstructorArgs[0] = context; try { if (-1 == name.indexOf(\u0026#39;.\u0026#39;)) { // 正常流程 // 走默认的xml解析来创建View view = onCreateView(context, parent, name, attrs); } else { view = createView(context, name, null, attrs); } } finally { mConstructorArgs[0] = lastContext; } } return view; } catch (InflateException e) { // ... } catch (ClassNotFoundException e) { // ... } catch (Exception e) { // ... } } public interface Factory { View onCreateView(String name, Context context, AttributeSet attrs); } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 // 自定义解析流程 public final View tryCreateView(@Nullable View parent, @NonNull String name, @NonNull Context context, @NonNull AttributeSet attrs) { if (name.equals(TAG_1995)) { // Let\u0026#39;s party like it\u0026#39;s 1995! return new BlinkLayout(context, attrs); } View view; if (mFactory2 != null) { // 优先使用Factory2创建 view = mFactory2.onCreateView(parent, name, context, attrs); } else if (mFactory != null) { // Factory2为空，则使用Factory创建 view = mFactory.onCreateView(name, context, attrs); } else { view = null; } // 问题1：为什么要对外提供Factory接口自定义解析xml呢？ // 答：在xml中除了系统默认支持的控件标签外，我们只能定义自定义的控件的标签，并且标签名必须是自定义控件的全限定类名，就是因为LayoutInflater自带的xml解析器是通过反射的方式直接创建控件的；但如果我们不想在xml中通过全限定类名来定义控件标签，就可以实现Factory接口自己解析创建控件 // Factory和Factory2都是用户自己创建的，如果都为空，则使用PrivateFactory，这是Framework创建的 if (view == null \u0026amp;\u0026amp; mPrivateFactory != null) { view = mPrivateFactory.onCreateView(parent, name, context, attrs); } // 问题2：为什么系统Framework还要实现Factory接口呢? // 答：因为Android系统后面新增了\u0026lt;fragment/\u0026gt;标签，这个没法通过反射类名创建对象，所以也得实现Factory接口 // 这个有点意思，感觉发现了新大陆 return view; } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 // 正常解析流程 private static final HashMap\u0026lt;String, Constructor\u0026lt;? extends View\u0026gt;\u0026gt; sConstructorMap = new HashMap\u0026lt;String, Constructor\u0026lt;? extends View\u0026gt;\u0026gt;(); public final View createView(@NonNull Context viewContext, @NonNull String name, @Nullable String prefix, @Nullable AttributeSet attrs) throws ClassNotFoundException, InflateException { Objects.requireNonNull(viewContext); Objects.requireNonNull(name); // 通过标签名从一个静态的HashMap中取出Constructor对象 // Constructor对象为反射后得到的构造器对象 Constructor\u0026lt;? extends View\u0026gt; constructor = sConstructorMap.get(name); if (constructor != null \u0026amp;\u0026amp; !verifyClassLoader(constructor)) { constructor = null; sConstructorMap.remove(name); } Class\u0026lt;? extends View\u0026gt; clazz = null; try { Trace.traceBegin(Trace.TRACE_TAG_VIEW, name); // 如果之前没创建过该标签的Constructor if (constructor == null) { // Class not found in the cache, see if it\u0026#39;s real, and try to add it // 通过标签名直接反射得到Class对象 clazz = Class.forName(prefix != null ? (prefix + name) : name, false, mContext.getClassLoader()).asSubclass(View.class); if (mFilter != null \u0026amp;\u0026amp; clazz != null) { boolean allowed = mFilter.onLoadClass(clazz); if (!allowed) { failNotAllowed(name, prefix, viewContext, attrs); } } // 通过Class对象得到其Constructor对象 constructor = clazz.getConstructor(mConstructorSignature); constructor.setAccessible(true); // 并存储到静态HashMap中缓存起来 sConstructorMap.put(name, constructor); } else { // If we have a filter, apply it to cached constructor if (mFilter != null) { // Have we seen this name before? Boolean allowedState = mFilterMap.get(name); if (allowedState == null) { // New class -- remember whether it is allowed clazz = Class.forName(prefix != null ? (prefix + name) : name, false, mContext.getClassLoader()).asSubclass(View.class); boolean allowed = clazz != null \u0026amp;\u0026amp; mFilter.onLoadClass(clazz); mFilterMap.put(name, allowed); if (!allowed) { failNotAllowed(name, prefix, viewContext, attrs); } } else if (allowedState.equals(Boolean.FALSE)) { failNotAllowed(name, prefix, viewContext, attrs); } } } Object lastContext = mConstructorArgs[0]; mConstructorArgs[0] = viewContext; Object[] args = mConstructorArgs; args[1] = attrs; try { // 通过Constructor的newInstance()方法，也就是反射的方式就行创建View对象，因为任何控件都继承于View final View view = constructor.newInstance(args); if (view instanceof ViewStub) { // Use the same context when inflating ViewStub later. final ViewStub viewStub = (ViewStub) view; viewStub.setLayoutInflater(cloneInContext((Context) args[0])); } return view; } finally { mConstructorArgs[0] = lastContext; } } catch (NoSuchMethodException e) { final InflateException ie = new InflateException( getParserStateDescription(viewContext, attrs) + \u0026#34;: Error inflating class \u0026#34; + (prefix != null ? (prefix + name) : name), e); ie.setStackTrace(EMPTY_STACK_TRACE); throw ie; } catch (ClassCastException e) { // If loaded class is not a View subclass final InflateException ie = new InflateException( getParserStateDescription(viewContext, attrs) + \u0026#34;: Class is not a View \u0026#34; + (prefix != null ? (prefix + name) : name), e); ie.setStackTrace(EMPTY_STACK_TRACE); throw ie; } catch (ClassNotFoundException e) { // If loadClass fails, we should propagate the exception. throw e; } catch (Exception e) { final InflateException ie = new InflateException( getParserStateDescription(viewContext, attrs) + \u0026#34;: Error inflating class \u0026#34; + (clazz == null ? \u0026#34;\u0026lt;unknown\u0026gt;\u0026#34; : clazz.getName()), e); ie.setStackTrace(EMPTY_STACK_TRACE); throw ie; } finally { Trace.traceEnd(Trace.TRACE_TAG_VIEW); } } 总结 综上所述，LayoutInflater.inflate()内部是通过Pull的方式解析xml，然后通过标签名进行反射创建出View对象，并将其的Class对象的Constructor对象保存到静态HashMap中缓存起来，这样下次解析同名的控件时就可以直接取出其的Constructor对象创建View了。另外，如果不想通过标签名反射创建View的，还可以实现LayoutInflater.Factory接口，并通过setFactory()传入实现类对象，从而实现自定义解析。\n关键词 Pull解析xml 反射标签名创建View 静态HashMap缓存Constructor LayoutInflater.Factory接口实现自定义解析 ","date":"2022-03-28T04:14:54-08:00","permalink":"https://pangfq.github.io/blog/p/android-view-source3/","title":"Activity绘制系列：3. LayoutInflater.inflate()"},{"content":"概述 在此之前，我们看了setContentView()的源码，看了LayoutInflater.inflate()的源码，都没发现Activity绘制的触发代码，那触发Activity绘制的代码到底在哪里呢？在Activity里根本没找到，我想静静啊。\n我闭上了眼睛，放空大脑，就这样放着放着，突然灵光一现：既然不在Activity里，那是不是在Activity外呢？\n因为Activity的生命周期都是由Framework层去调用的，其中生命周期函数onResume()表示Activity的可见性，Activity绘制出来才能可见，所以如果找到了Activity的onResume()函数的调用处，那是不是就找到了触发Activity绘制的代码了呢？\n确定了思路，马上开始看源码，那从哪里看起呢？当然是启动Activity的startActivity()方法了。\n源码 1 2 3 4 5 6 7 8 public void startActivity(Intent intent, @Nullable Bundle options) { if (options != null) { // 调用startActivityForResult() startActivityForResult(intent, -1, options); } else { startActivityForResult(intent, -1); } } 1 2 3 4 5 6 7 8 9 10 11 public void startActivityForResult(Intent intent, int requestCode, Bundle options) { if (mParent == null) { options = transferSpringboardActivityOptions(options); // 调用Instrumentation的execStartActivity() Instrumentation.ActivityResult ar = mInstrumentation.execStartActivity( this, mMainThread.getApplicationThread(), mToken, this, intent, requestCode, options); // ... } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 public ActivityResult execStartActivity( Context who, IBinder contextThread, IBinder token, Activity target, Intent intent, int requestCode, Bundle options) { IApplicationThread whoThread = (IApplicationThread) contextThread; // ... try { intent.migrateExtraStreamToClipData(); intent.prepareToLeaveProcess(who); // 调用ActivityTaskManager.getService().startActivity() int result = ActivityTaskManager.getService() .startActivity(whoThread, who.getBasePackageName(), intent, intent.resolveTypeIfNeeded(who.getContentResolver()), token, target != null ? target.mEmbeddedID : null, requestCode, 0, null, options); checkStartActivityResult(result, intent); } catch (RemoteException e) { throw new RuntimeException(\u0026#34;Failure from system\u0026#34;, e); } return null; } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 // ActivityTaskManager.getService()会得到一个IActivityTaskManager实例 public static IActivityTaskManager getService() { // 这个实例是放在一个单例中的 return IActivityTaskManagerSingleton.get(); } // 就是这个Singleton private static final Singleton\u0026lt;IActivityTaskManager\u0026gt; IActivityTaskManagerSingleton = new Singleton\u0026lt;IActivityTaskManager\u0026gt;() { @Override protected IActivityTaskManager create() { // 此处创建IActivityTaskManager对象，并返回 final IBinder b = ServiceManager.getService(Context.ACTIVITY_TASK_SERVICE); // 原来IActivityTaskManager是一个aidl，也就是Binder，所以startActivity()还是一个跨进程通信的过程 return IActivityTaskManager.Stub.asInterface(b); } }; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 // ActivityTaskManagerService类实现了IActivityTaskManager.Stub接口，所以跨进程到ATMS中进行处理 // ATMS所在进程叫SystemServer进程，这部分内容后续专门写文章讲，此处不再赘述 public class ActivityTaskManagerService extends IActivityTaskManager.Stub { @Override public final int startActivity(IApplicationThread caller, String callingPackage, Intent intent, String resolvedType, IBinder resultTo, String resultWho, int requestCode, int startFlags, ProfilerInfo profilerInfo, Bundle bOptions) { // 调用了startActivityAsUser() return startActivityAsUser(caller, callingPackage, intent, resolvedType, resultTo, resultWho, requestCode, startFlags, profilerInfo, bOptions, UserHandle.getCallingUserId()); } int startActivityAsUser(IApplicationThread caller, String callingPackage, Intent intent, String resolvedType, IBinder resultTo, String resultWho, int requestCode, int startFlags, ProfilerInfo profilerInfo, Bundle bOptions, int userId, boolean validateIncomingUser) { enforceNotIsolatedCaller(\u0026#34;startActivityAsUser\u0026#34;); userId = getActivityStartController().checkTargetUser(userId, validateIncomingUser, Binder.getCallingPid(), Binder.getCallingUid(), \u0026#34;startActivityAsUser\u0026#34;); // 又调用了ActivityStarter.execute() return getActivityStartController().obtainStarter(intent, \u0026#34;startActivityAsUser\u0026#34;) .setCaller(caller) .setCallingPackage(callingPackage) .setResolvedType(resolvedType) .setResultTo(resultTo) .setResultWho(resultWho) .setRequestCode(requestCode) .setStartFlags(startFlags) .setProfilerInfo(profilerInfo) .setActivityOptions(bOptions) .setMayWait(userId) .execute(); } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 class ActivityStarter { int execute() { try { if (mRequest.mayWait) { return startActivityMayWait(mRequest.caller, mRequest.callingUid, mRequest.callingPackage, mRequest.realCallingPid, mRequest.realCallingUid, mRequest.intent, mRequest.resolvedType, mRequest.voiceSession, mRequest.voiceInteractor, mRequest.resultTo, mRequest.resultWho, mRequest.requestCode, mRequest.startFlags, mRequest.profilerInfo, mRequest.waitResult, mRequest.globalConfig, mRequest.activityOptions, mRequest.ignoreTargetSecurity, mRequest.userId, mRequest.inTask, mRequest.reason, mRequest.allowPendingRemoteAnimationRegistryLookup, mRequest.originatingPendingIntent, mRequest.allowBackgroundActivityStart); } else { // 调用startActivity() return startActivity(mRequest.caller, mRequest.intent, mRequest.ephemeralIntent, mRequest.resolvedType, mRequest.activityInfo, mRequest.resolveInfo, mRequest.voiceSession, mRequest.voiceInteractor, mRequest.resultTo, mRequest.resultWho, mRequest.requestCode, mRequest.callingPid, mRequest.callingUid, mRequest.callingPackage, mRequest.realCallingPid, mRequest.realCallingUid, mRequest.startFlags, mRequest.activityOptions, mRequest.ignoreTargetSecurity, mRequest.componentSpecified, mRequest.outActivity, mRequest.inTask, mRequest.reason, mRequest.allowPendingRemoteAnimationRegistryLookup, mRequest.originatingPendingIntent, mRequest.allowBackgroundActivityStart); } } finally { onExecutionComplete(); } } // 参数真的多啊 private int startActivity(final ActivityRecord r, ActivityRecord sourceRecord, IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor, int startFlags, boolean doResume, ActivityOptions options, TaskRecord inTask, ActivityRecord[] outActivity, boolean restrictedBgActivity) { int result = START_CANCELED; final ActivityStack startedActivityStack; try { mService.mWindowManager.deferSurfaceLayout(); // 调用startActivityUnchecked() result = startActivityUnchecked(r, sourceRecord, voiceSession, voiceInteractor, startFlags, doResume, options, inTask, outActivity, restrictedBgActivity); } // ... } private int startActivityUnchecked(final ActivityRecord r, ActivityRecord sourceRecord, IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor, int startFlags, boolean doResume, ActivityOptions options, TaskRecord inTask, ActivityRecord[] outActivity, boolean restrictedBgActivity) { // ... if (mDoResume) { // 调用RootActivityContainer的resumeFocusedStacksTopActivities() mRootActivityContainer.resumeFocusedStacksTopActivities(); } // ... } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class RootActivityContainer extends ConfigurationContainer implements DisplayManager.DisplayListener { boolean resumeFocusedStacksTopActivities( ActivityStack targetStack, ActivityRecord target, ActivityOptions targetOptions) { if (!mStackSupervisor.readyToResume()) { return false; } boolean result = false; if (targetStack != null \u0026amp;\u0026amp; (targetStack.isTopStackOnDisplay() || getTopDisplayFocusedStack() == targetStack)) { // 调用ActivityStack的resumeTopActivityUncheckedLocked() result = targetStack.resumeTopActivityUncheckedLocked(target, targetOptions); } } } 1 2 3 4 5 6 7 class ActivityStack extends ConfigurationContainer { private boolean resumeTopActivityInnerLocked(ActivityRecord prev, ActivityOptions options) { // ... mStackSupervisor.startSpecificActivityLocked(next, true, false); // ... } } 1 2 3 4 5 6 7 8 9 10 11 12 public class ActivityStackSupervisor implements RecentTasks.Callbacks { void startSpecificActivityLocked(ActivityRecord r, boolean andResume, boolean checkConfig)\t{\trealStartActivityLocked(r, wpc, andResume, checkConfig); } boolean realStartActivityLocked(ActivityRecord r, WindowProcessController proc, boolean andResume, boolean checkConfig) throws RemoteException { // 封装成ClientTransaction mService.getLifecycleManager().scheduleTransaction(clientTransaction); } } 1 2 3 4 5 6 7 8 9 10 11 12 class ClientLifecycleManager { void scheduleTransaction(ClientTransaction transaction) throws RemoteException { // IApplicationThread是客户端的Binder，ATMS就是通过该Binder最终回到APP进程的 final IApplicationThread client = transaction.getClient(); transaction.schedule(); if (!(client instanceof Binder)) { // the transaction is executed on client in ActivityThread. // 这个Transaction是被客户端的ActivityThread执行的 transaction.recycle(); } } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 public final class ActivityThread extends ClientTransactionHandler { // ApplicationThread继承了IApplicationThread.Stub，所以是一个主进程的Binder // 是ActivityThread的内部类 private class ApplicationThread extends IApplicationThread.Stub { // ... // ATMS会通过binder回调该方法 public void scheduleApplicationInfoChanged(ApplicationInfo ai) { mH.removeMessages(H.APPLICATION_INFO_CHANGED, ai); // 通过主线程的Handler回到主线程 sendMessage(H.APPLICATION_INFO_CHANGED, ai); } // ... } private Activity performLaunchActivity(ActivityClientRecord r, Intent customIntent) { // ... ContextImpl appContext = createBaseContextForActivity(r); Activity activity = null; try { java.lang.ClassLoader cl = appContext.getClassLoader(); // 调用Instrumentation去创建Activity activity = mInstrumentation.newActivity( cl, component.getClassName(), r.intent); StrictMode.incrementExpectedActivityCount(activity.getClass()); r.intent.setExtrasClassLoader(cl); r.intent.prepareToEnterProcess(); if (r.state != null) { r.state.setClassLoader(cl); } } catch (Exception e) { if (!mInstrumentation.onException(activity, e)) { throw new RuntimeException( \u0026#34;Unable to instantiate activity \u0026#34; + component + \u0026#34;: \u0026#34; + e.toString(), e); } } // ... if (r.isPersistable()) { mInstrumentation.callActivityOnCreate(activity, r.state, r.persistentState); } else { // 创建完Activity后，还是通过Instrumentation来调用Activity的生命周期 mInstrumentation.callActivityOnCreate(activity, r.state); } } @Override public void handleResumeActivity(IBinder token, boolean finalStateRequest, boolean isForward, String reason) { // ... // 调用Activity的onResume()生命周期方法 final ActivityClientRecord r = performResumeActivity(token, finalStateRequest, reason); // ... final Activity a = r.activity; // ... if (r.window == null \u0026amp;\u0026amp; !a.mFinished \u0026amp;\u0026amp; willBeVisible) { // 取出Activity的Window r.window = r.activity.getWindow(); // 取出Activity的DecorView View decor = r.window.getDecorView(); decor.setVisibility(View.INVISIBLE); // 取出Activity的WindowManager ViewManager wm = a.getWindowManager(); WindowManager.LayoutParams l = r.window.getAttributes(); a.mDecor = decor; // ... if (a.mVisibleFromClient) { if (!a.mWindowAdded) { a.mWindowAdded = true; // 调用WindowManager的addView()，将DecorView添加到Window中 // 内部会调用WindowManagerGlobal的addView() // 再继续调用ViewRootImpl的setView()触发DecorView的绘制 // 所以此处就是就是Activity绘制的开始 wm.addView(decor, l); } else { a.onWindowAttributesChanged(l); } } } else if (!willBeVisible) { if (localLOGV) Slog.v(TAG, \u0026#34;Launch \u0026#34; + r + \u0026#34; mStartedActivity set\u0026#34;); r.hideForNow = true; } if (!r.activity.mFinished \u0026amp;\u0026amp; willBeVisible \u0026amp;\u0026amp; r.activity.mDecor != null \u0026amp;\u0026amp; !r.hideForNow) { // ... WindowManager.LayoutParams l = r.window.getAttributes(); if ((l.softInputMode \u0026amp; WindowManager.LayoutParams.SOFT_INPUT_IS_FORWARD_NAVIGATION) != forwardBit) { l.softInputMode = (l.softInputMode \u0026amp; (~WindowManager.LayoutParams.SOFT_INPUT_IS_FORWARD_NAVIGATION)) | forwardBit; if (r.activity.mVisibleFromClient) { ViewManager wm = a.getWindowManager(); View decor = r.window.getDecorView(); // 此处也会触发DecorView的绘制 // WindowManager实现了ViewManager接口，该接口中有三个方法:addView()、updateViewLayout()、removeView()，分别对应View的添加、更新、删除操作，所以添加和更新一定会触发View的绘制 wm.updateViewLayout(decor, l); } } // ... } Looper.myQueue().addIdleHandler(new Idler()); } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 // Activity的生命周期都是通过Instrumentation调用的 public class Instrumentation { // 创建Activity public Activity newActivity(ClassLoader cl, String className, Intent intent) throws InstantiationException, IllegalAccessException, ClassNotFoundException { String pkg = intent != null \u0026amp;\u0026amp; intent.getComponent() != null ? intent.getComponent().getPackageName() : null; // 调用了一个工厂去创建Activity return getFactory(pkg).instantiateActivity(cl, className, intent); } // 调用Activity的生命周期方法onResume() public void callActivityOnResume(Activity activity) { activity.mResumed = true; activity.onResume(); if (mActivityMonitors != null) { synchronized (mSync) { final int N = mActivityMonitors.size(); for (int i=0; i\u0026lt;N; i++) { final ActivityMonitor am = mActivityMonitors.get(i); am.match(activity, activity, activity.getIntent()); } } } } public void callActivityOnCreate(Activity activity){//...} public void callActivityOnDestroy(Activity activity){//...} public void callActivityOnStart(Activity activity){//...} // ... } 1 2 3 4 5 6 7 8 public class AppComponentFactory { public @NonNull Activity instantiateActivity(@NonNull ClassLoader cl, @NonNull String className, @Nullable Intent intent) throws InstantiationException, IllegalAccessException, ClassNotFoundException { // 原来最后是通过一个ClassLoader创建出的Activity，这个ClassLoader是从Context获取的 return (Activity) cl.loadClass(className).newInstance(); } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 public final class WindowManagerGlobal { // 是一个单例，一个进程就只有一个 public static WindowManagerGlobal getInstance() { synchronized (WindowManagerGlobal.class) { if (sDefaultWindowManager == null) { sDefaultWindowManager = new WindowManagerGlobal(); } return sDefaultWindowManager; } } public void addView(View view, ViewGroup.LayoutParams params, Display display, Window parentWindow) { // ... ViewRootImpl root; View panelParentView = null; synchronized (mLock) { // ... // 创建ViewRootImpl对象，该对象会持有DecorView，跟它的名字一样，ViewRoot，视图根 // WindowManager通过ViewRootImpl来管理View，就跟访问链表要先通过head指针一样 root = new ViewRootImpl(view.getContext(), display); view.setLayoutParams(wparams); mViews.add(view); mRoots.add(root); mParams.add(wparams); try { // 进入到ViewRootImpl中的setView() root.setView(view, wparams, panelParentView); } catch (RuntimeException e) { // BadTokenException or InvalidDisplayException, clean up. if (index \u0026gt;= 0) { removeViewLocked(index, true); } throw e; } } } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 public final class ViewRootImpl implements ViewParent, View.AttachInfo.Callbacks, ThreadedRenderer.DrawCallbacks { public void setView(View view, WindowManager.LayoutParams attrs, View panelParentView) { // ... requestLayout(); // ... } public void requestLayout() { // ... scheduleTraversals(); // ... } void scheduleTraversals() { if (!mTraversalScheduled) { mTraversalScheduled = true; // 因为涉及到View，所以要通过Handler提交到主线程处理 // 这里就有意思了，发现先提了一个同步屏障消息 // 同步屏障消息的作用是屏蔽掉当前MessageQueue中的同步消息，优先让异步消息执行 // 而绘制View的操作会放到Runnable中，并将Message设置成异步消息，这样绘制View就会优先得到处理 mTraversalBarrier = mHandler.getLooper().getQueue().postSyncBarrier(); mChoreographer.postCallback( Choreographer.CALLBACK_TRAVERSAL, mTraversalRunnable, null); } } final class TraversalRunnable implements Runnable { @Override public void run() { doTraversal(); }\t} void doTraversal() { if (mTraversalScheduled) { mTraversalScheduled = false; // 开始执行了，就把同步屏障移除吧 mHandler.getLooper().getQueue().removeSyncBarrier(mTraversalBarrier); // 执行遍历，为啥要叫遍历呢？是因为DecorView本身就是一个View树，所以它的绘制就是一个深度优先遍历的过程，所以就叫Tralversals performTraversals(); } } private void performTraversals() { // ... performMeasure(childWidthMeasureSpec, childHeightMeasureSpec); // ... performLayout(lp, mWidth, mHeight); // ... performDraw(); // ... } private void performMeasure(int childWidthMeasureSpec,int childHeightMeasureSpec){ if (mView == null) { return; } Trace.traceBegin(Trace.TRACE_TAG_VIEW, \u0026#34;measure\u0026#34;); try { // 调用DecorView的measure()开始进入测量环节 mView.measure(childWidthMeasureSpec, childHeightMeasureSpec); } finally { Trace.traceEnd(Trace.TRACE_TAG_VIEW); } } // performLayout()和performDraw()就不贴出来了 } 源码跟踪到此结束。\n总结 我们最终通过Activity的startActivity()找到了Activity绘制的触发点，还顺便了解了Activity的启动流程，这一趟没白来，下面简要总结下整个流程：\nActivity的startActivity()开始 Instrumentation调用Binder对象IActivityTaskManager跨进程进入到ActivityTaskManagerService(ATMS)中 经过ATMS的一系列处理，包括Activity是否在Manifest.xml中注册过等等 ATMS处理完，会调用Binder对象IApplicationThread跨进程回到APP进程ActivityThread中 ActivityThread会调用主线程的Handler回调到主线程 ActivityThread会调用performCreateActivity()，由Instrumentation通过ClassLoader创建出Activity对象，并调用Activity的onCreate() ActivityThread会调用handleResumeActivity()，同样通过Instrumentation调用Activity的onResume()；并通过Activity的WindowManager调用addView(mDecorView)将Activity的DecorView添加进来 WindowManager内部通过桥梁模式继续调用WindowManagerGlobal调用addView() WindowManagerGlobal的addView()内部会创建ViewRootImpl并持有DecorView，然后调用ViewRootImpl的setView(mDecorView) ViewRootImpl的setView()内部会先通过Handler发送一个同步屏障消息，然后将触发DecorView绘制的操作放到一个异步消息中，来保证View绘制优先处理。 关键词 Instrumentation IActivityTaskManager ActivityTaskManagerService IApplicationThread ActivityThread WindowManager extends ViewManager WindowManagerGlobal ViewRootImpl ","date":"2022-03-28T04:14:54-08:00","permalink":"https://pangfq.github.io/blog/p/android-view-source4/","title":"Activity绘制系列：4. startActivity()"},{"content":"概述 Activity绘制到屏幕上要经历3个步骤，measure、layout、draw，分别是测量、布局、绘制，作用分别是确定宽高、确定位置、确定外观。\n下面先从measure过程讲起，还是看源码，但是要从哪里看起呢？\nActivity的绘制是从DecorView开始的，当然是从调用DecorView的measure()地方开始看起，也就是ViewRootImpl类。\n源码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 public final class ViewRootImpl implements ViewParent, View.AttachInfo.Callbacks, ThreadedRenderer.DrawCallbacks { public final WindowManager.LayoutParams mWindowAttributes = new WindowManager.LayoutParams(); private void performMeasure(int childWidthMeasureSpec, int childHeightMeasureSpec) { if (mView == null) { return; } Trace.traceBegin(Trace.TRACE_TAG_VIEW, \u0026#34;measure\u0026#34;); try { // 此处开始正式调用DecorView的measure()方法，可以看到需要传入两个参数，分别是宽的测量规格和高的测量规格，我们看下这两个参数是从哪里构造出来的 mView.measure(childWidthMeasureSpec, childHeightMeasureSpec); } finally { Trace.traceEnd(Trace.TRACE_TAG_VIEW); } } private boolean measureHierarchy(final View host, final WindowManager.LayoutParams lp, final Resources res, final int desiredWindowWidth, final int desiredWindowHeight) { int childWidthMeasureSpec; int childHeightMeasureSpec; if (lp.width == ViewGroup.LayoutParams.WRAP_CONTENT) { // On large screens, we don\u0026#39;t want to allow dialogs to just // stretch to fill the entire width of the screen to display // one line of text. First try doing the layout at a smaller // size to see if it will fit. final DisplayMetrics packageMetrics = res.getDisplayMetrics(); res.getValue(com.android.internal.R.dimen.config_prefDialogWidth, mTmpValue, true); int baseSize = 0; if (mTmpValue.type == TypedValue.TYPE_DIMENSION) { baseSize = (int)mTmpValue.getDimension(packageMetrics); } if (baseSize != 0 \u0026amp;\u0026amp; desiredWindowWidth \u0026gt; baseSize) { // 通过size和lp(LayoutParam)来构造DecorView的MeasureSpec // baseSize就是屏幕的宽 // lp来自于成员变量mWindowAttributes，是一个WindowManager.LayoutParams，宽高都是MATCH_PARENT childWidthMeasureSpec = getRootMeasureSpec(baseSize, lp.width); childHeightMeasureSpec = getRootMeasureSpec(desiredWindowHeight, lp.height); performMeasure(childWidthMeasureSpec, childHeightMeasureSpec); } } // ... return windowSizeMayChange; } private void performTraversals() { // ... WindowManager.LayoutParams lp = mWindowAttributes; // ... } private static int getRootMeasureSpec(int windowSize, int rootDimension) { int measureSpec; switch (rootDimension) { case ViewGroup.LayoutParams.MATCH_PARENT: // Window can\u0026#39;t resize. Force root view to be windowSize. // 通过size和mode来创建MeasureSpec // 对于DecorView来讲，size就是屏幕尺寸，lp是MATCH_PARENT，所以mode就是EXACTLY // 换句话说，DecorView的MeasureSpec是由屏幕来构造出来的 measureSpec = MeasureSpec.makeMeasureSpec(windowSize, MeasureSpec.EXACTLY); break; case ViewGroup.LayoutParams.WRAP_CONTENT: // Window can resize. Set max size for root view. measureSpec = MeasureSpec.makeMeasureSpec(windowSize, MeasureSpec.AT_MOST); break; default: // Window wants to be an exact size. Force root view to be that size. measureSpec = MeasureSpec.makeMeasureSpec(rootDimension, MeasureSpec.EXACTLY); break; } return measureSpec; } } 接下来我们看看ViewGroup的measure过程。\nViewGroup是一个抽象类，没有定义测量的具体过程，具体实现由子类完成，下面以LinearLayout为例说明下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 public class LinearLayout extends ViewGroup { @Override protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) { if (mOrientation == VERTICAL) { measureVertical(widthMeasureSpec, heightMeasureSpec); } else { measureHorizontal(widthMeasureSpec, heightMeasureSpec); } } void measureHorizontal(int widthMeasureSpec, int heightMeasureSpec) { // ... // 获取父视图传来的测量模式 final int widthMode = MeasureSpec.getMode(widthMeasureSpec); final int heightMode = MeasureSpec.getMode(heightMeasureSpec); // ... // 遍历所有子视图 for (int i = 0; i \u0026lt; count; ++i) { // 测量子视图 measureChildBeforeLayout(child, i, widthMeasureSpec, usedWidth, heightMeasureSpec, 0); // 获取子视图的宽 final int childWidth = child.getMeasuredWidth(); // ... } // 测量完所有子视图之后，根据子视图的宽高，最后设置自身的宽高 setMeasuredDimension(resolveSizeAndState(maxWidth, widthMeasureSpec, childState), heightSizeAndState); } void measureChildBeforeLayout(View child, int childIndex, int widthMeasureSpec, int totalWidth, int heightMeasureSpec, int totalHeight) { // 调用的是ViewGroup中的方法 measureChildWithMargins(child, widthMeasureSpec, totalWidth, heightMeasureSpec, totalHeight); } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 public abstract class ViewGroup { protected void measureChildWithMargins(View child, int parentWidthMeasureSpec, int widthUsed, int parentHeightMeasureSpec, int heightUsed) { // 获取子视图的LayoutParams final MarginLayoutParams lp = (MarginLayoutParams) child.getLayoutParams(); // 构造子视图的MeasureSpec // size：要减去父视图的padding和子视图的margin // mode：父视图的MeasureSpec和子视图的LayoutParams // 所以，可以看出传入子视图measure()的测量规格（size和mode），是由父视图和子视图共同决定的 final int childWidthMeasureSpec = getChildMeasureSpec(parentWidthMeasureSpec, mPaddingLeft + mPaddingRight + lp.leftMargin + lp.rightMargin + widthUsed, lp.width); final int childHeightMeasureSpec = getChildMeasureSpec(parentHeightMeasureSpec, mPaddingTop + mPaddingBottom + lp.topMargin + lp.bottomMargin + heightUsed, lp.height); // 测量子视图 child.measure(childWidthMeasureSpec, childHeightMeasureSpec); } } 最后看下View的measure过程：\n1 2 3 4 5 6 7 8 public class View { protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) { // 对于View来讲，测量规格已经由父视图根据父视图的MeasureSpec和View自己的LayoutParams计算过了，所以如果没有特殊需求，可以直接设置自身的宽高即可 setMeasuredDimension(getDefaultSize(getSuggestedMinimumWidth(), widthMeasureSpec), getDefaultSize(getSuggestedMinimumHeight(), heightMeasureSpec)); } } 总结 对于measure的过程，可以分为两部分看：\nViewGroup View ViewGroup又可以分为顶级ViewGroup（DecorView）和非顶级ViewGroup，区别只是在构造MeasureSpec上有差异，虽然两者的MeasureSpec都是来自父视图，但DecorView因为已经是顶级视图，它没有父视图了，它的MeasureSpec是来自于屏幕，或者说Window，size和mode都是固定的，size是屏幕宽高，mode是exactly，其实也可以把DecorView看成是特殊的ViewGroup；\n对于非顶级的ViewGroup来讲，MeasureSpec同样来自父视图，size由父视图的size减去padding，再减去自身的margin；mode是由父视图的MeasureSpec和自身的LayoutParams共同决定；\nmeasure流程是先遍历其所有子视图，依次进行measure，并得到measure之后的宽高，最后据此来设置自身的宽高。\n对于View来讲，MeasureSpec参数的构造和非ViewGroup一样，不再赘述；\n而measure流程是直接设置通过MeasureSpec参数设置宽高，因为MeasureSpec已经由父视图计算好了，如果没有其他特殊需求，直接设置即可。\n问题 一个Activity中有一个LinearLayout，LinearLayout中又有一个Button，请问measure的过程，LinearLayout和Button哪个先measure完成？\n答：Button，说下ViewGroup的measure源码流程即可：\n遍历所有子视图 依次measure子视图，并获取其measure后的宽高 根据measure后的宽高来确定自身的宽高 可以看到ViewGroup中调用了子视图的measure()，所以，Button先measure完成。\n","date":"2022-03-28T04:14:54-08:00","permalink":"https://pangfq.github.io/blog/p/android-view-source5/","title":"Activity绘制系列：5. onMeasure()"},{"content":"概述 MeasureSpec，测量规格，用在View的measure过程，是一个int类型的值，但表示了两个属性：\n测量模式（mode） 测量大小（size） 下面通过源码来讲解其是如何用一个int值表示两个属性的。\n源码 先来看下View的onMeasure()：\n1 2 3 4 @Override protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) { // ... } onMeasure()会传入两个int类型的值，分别是宽的测量规格和高的测量规格。\n我们可以通过MeasureSpec.getMode(widthMeasureSpec)和MeasureSpec.getSize(widthMeasureSpec)来获取宽的测量模式和测量大小；\n还可以通过MeasureSpec.makeMeasureSpec(size, mode)将size和mode合并成测量规格，并返回一个int值；\n所以合并和分解的代码都在MeasureSpec这个类中，我们来看下源码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 // MeasureSpec是定义在View类中的静态内部类 public class View implements Drawable.Callback, KeyEvent.Callback, AccessibilityEventSource { // ... public static class MeasureSpec { // 移动30位 private static final int MODE_SHIFT = 30; // 掩码，高两位都是1，低30位都是0 private static final int MODE_MASK = 0x3 \u0026lt;\u0026lt; MODE_SHIFT; public @interface MeasureSpecMode {} /** * Measure specification mode: The parent has not imposed any constraint * on the child. It can be whatever size it wants. */ public static final int UNSPECIFIED = 0 \u0026lt;\u0026lt; MODE_SHIFT;// 高两位是00，低30位都是0 /** * Measure specification mode: The parent has determined an exact size * for the child. The child is going to be given those bounds regardless * of how big it wants to be. */ public static final int EXACTLY = 1 \u0026lt;\u0026lt; MODE_SHIFT;// 高两位是01，低30位都是0 /** * Measure specification mode: The child can be as large as it wants up * to the specified size. */ public static final int AT_MOST = 2 \u0026lt;\u0026lt; MODE_SHIFT;// 高两位是10，低30位都是0 /** * Creates a measure specification based on the supplied size and mode. * * The mode must always be one of the following: * \u0026lt;ul\u0026gt; * \u0026lt;li\u0026gt;{@link android.view.View.MeasureSpec#UNSPECIFIED}\u0026lt;/li\u0026gt; * \u0026lt;li\u0026gt;{@link android.view.View.MeasureSpec#EXACTLY}\u0026lt;/li\u0026gt; * \u0026lt;li\u0026gt;{@link android.view.View.MeasureSpec#AT_MOST}\u0026lt;/li\u0026gt; * \u0026lt;/ul\u0026gt; * * \u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;Note:\u0026lt;/strong\u0026gt; On API level 17 and lower, makeMeasureSpec\u0026#39;s * implementation was such that the order of arguments did not matter * and overflow in either value could impact the resulting MeasureSpec. * {@link android.widget.RelativeLayout} was affected by this bug. * Apps targeting API levels greater than 17 will get the fixed, more strict * behavior.\u0026lt;/p\u0026gt; * * @param size the size of the measure specification * @param mode the mode of the measure specification * @return the measure specification based on size and mode */ // 把size和mode合并成测量规格 public static int makeMeasureSpec(@IntRange(from = 0, to = (1 \u0026lt;\u0026lt; MeasureSpec.MODE_SHIFT) - 1) int size, int mode) { if (sUseBrokenMakeMeasureSpec) { return size + mode; } else { // 1. 先用掩码分别与size、mode进行与运算，清洗数据； // 2. 然后将清洗后的结果进行或运算合并到一起得到一个int值。 return (size \u0026amp; ~MODE_MASK) | (mode \u0026amp; MODE_MASK); // 问题：size | mode 直接进行或运算就可以合并在一起，那为啥还要各自先和掩码进行与运算呢？ // 答：因为size和mode是从外部传进来的，所以无法保证mode只用到高2位，size只用到低30位，所以要进行数据的清洗，方法就是与运算，mode和高2位是1的值进行与运算，size和低30位是1的值进行与运算，最后将计算完的结果进行或运算即可。 } } /** * Extracts the mode from the supplied measure specification. * * @param measureSpec the measure specification to extract the mode from * @return {@link android.view.View.MeasureSpec#UNSPECIFIED}, * {@link android.view.View.MeasureSpec#AT_MOST} or * {@link android.view.View.MeasureSpec#EXACTLY} */ @MeasureSpecMode public static int getMode(int measureSpec) { //noinspection ResourceType // 与高2位是1低30位是0的掩码进行与运算得到mode return (measureSpec \u0026amp; MODE_MASK); } /** * Extracts the size from the supplied measure specification. * * @param measureSpec the measure specification to extract the size from * @return the size in pixels defined in the supplied measure specification */ public static int getSize(int measureSpec) { // 与高2位是0低30位是1的掩码进行与运算得到size return (measureSpec \u0026amp; ~MODE_MASK); } // ... } } 总结 具体分析都加到源码的注释里了，Android系统源码很多都有用到位运算的地方，使用位运算优点是高效，但缺点就是难懂，因为要转成二进制才能理解。\n这里的MeasureSpec将size和mode两个属性通过位运算合并到一个int值里，可以减少些内存占用，但造成了理解上的障碍，是非功过，各位自行评说吧。\n","date":"2022-03-28T04:14:54-08:00","permalink":"https://pangfq.github.io/blog/p/android-view-source5.2/","title":"Activity绘制系列：5.2 MeasureSpec"},{"content":"概述 layout过程是确定视图的位置，也就是确定4个参数，left、top、right、bottom，这4个参数是相对于所在父视图的位置，所以layout的过程是确定位置，而且是确定当前视图所在父视图的位置。\n依然从ViewRootImpl类开始看起，这样可以看全。\n源码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 public final class ViewRootImpl implements ViewParent, View.AttachInfo.Callbacks, ThreadedRenderer.DrawCallbacks { private void performTraversals() { // ... // mWidth、mHeight是通过上面measure后得到的宽和高 performLayout(lp, mWidth, mHeight); // ... } private void performLayout(WindowManager.LayoutParams lp, int desiredWindowWidth, int desiredWindowHeight) { // ... final View host = mView; if (host == null) { return; } // 可以看到，left和top都是0，也就是说DecorView的左上角与父视图的左上角重合，DecorView的父视图就是屏幕了，剩下right和bottom分别是width和height，因为right-left=width，而left=0，所以right=width，height同理。 host.layout(0, 0, host.getMeasuredWidth(), host.getMeasuredHeight()); // ... } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 public abstract class ViewGroup extends View implements ViewParent, ViewManager {\t@Override public final void layout(int l, int t, int r, int b) { if (!mSuppressLayout \u0026amp;\u0026amp; (mTransition == null || !mTransition.isChangingLayout())) { if (mTransition != null) { mTransition.layoutChange(this); } // ViewGroup调用的是View的layout() super.layout(l, t, r, b); } else { // record the fact that we noop\u0026#39;d it; request layout when transition finishes mLayoutCalledWhileSuppressed = true; } } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 public class View implements Drawable.Callback, KeyEvent.Callback, AccessibilityEventSource { public void layout(int l, int t, int r, int b) { // ... // 先通过setFrame(l, t, r, b)确定自身的位置 boolean changed = isLayoutModeOptical(mParent) ? setOpticalFrame(l, t, r, b) : setFrame(l, t, r, b); if (changed || (mPrivateFlags \u0026amp; PFLAG_LAYOUT_REQUIRED) == PFLAG_LAYOUT_REQUIRED) { // 再调用onLayout()确定子View的位置 onLayout(changed, l, t, r, b); } // 可以看到layout流程和measure正好相反，measure是确定所有子View的宽高，最后再确定自己的宽高 // layout是先确定自己的位置，再确定所有子View的位置 // ... } protected boolean setFrame(int left, int top, int right, int bottom) { // ... mLeft = left; mTop = top; mRight = right; mBottom = bottom; // ... } } 因为onLayout()在View和ViewGroup中都是抽象方法，具体实现在子类中，我们还是以LinearLayout为例看看其onLayout()的源码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 public class LinearLayout { @Override protected void onLayout(boolean changed, int l, int t, int r, int b) { // 根据方向属性分成两个方法 if (mOrientation == VERTICAL) { layoutVertical(l, t, r, b); } else { layoutHorizontal(l, t, r, b); } } void layoutVertical(int left, int top, int right, int bottom) { // ... // for循环遍历所有子View for (int i = 0; i \u0026lt; count; i++) { final View child = getVirtualChildAt(i); if (child == null) { childTop += measureNullChild(i); } else if (child.getVisibility() != GONE) { // ... setChildFrame(child, childLeft, childTop + getLocationOffset(child), childWidth, childHeight); // 可以看到下一个子View的top，就要再加上当前View的height，也就是按照竖直方向排列子View childTop += childHeight + lp.bottomMargin + getNextLocationOffset(child); // ... } } } } 总结 对于layout过程，也可以分为两部分：\nViewGroup View 同样的ViewGroup也要分为DecorView和非DecorView，区别同样是构造传参的差异；\n对于DecorView来讲，父视图就是屏幕了，所以left、top都是0，right和bottom是屏幕的宽和高；\n对于非DecorView来讲，就看自身所在的父视图是什么布局形式了，如果是LinearLayout，就按照线性排列，比如竖直方向，那么top就要加上上个子视图的height，然后再传给子视图的layout()方法设置位置；\n另外ViewGroup是先确定自身的位置，再确定子视图的位置，这个和measure的过程正好相反；\n对于View来讲，位置由父视图计算好并传入，直接通过setFrame()设置位置即可。\n问题 layout的过程，是先确定ViewGroup的位置呢？还是先确定View的位置呢？\n答：先确定ViewGroup的位置，再确定View的位置。\n这个看过源码就明白了，具体讲下ViewGroup的layout流程：\n调用setFrame()设置自己的位置 遍历所有子View 构造子View的位置参数，并调用子View的onLayout()方法 跟measure的顺序不一样。\n","date":"2022-03-28T04:14:54-08:00","permalink":"https://pangfq.github.io/blog/p/android-view-source6/","title":"Activity绘制系列：6. onLayout()"},{"content":"概述 draw过程是确定视图外观，会传入canvas参数进行绘制。\n我们还是从RootViewImpl开始看起。\n源码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 public class ViewRootImpl { // 直接new出来的Surface public final Surface mSurface = new Surface(); private void performDraw() { // ... boolean canUseAsync = draw(fullRedrawNeeded); // ... } private boolean draw(boolean fullRedrawNeeded) { Surface surface = mSurface; // ... if (!drawSoftware(surface, mAttachInfo, xOffset, yOffset, scalingRequired, dirty, surfaceInsets)) { return false; } // ... } private boolean drawSoftware(Surface surface, AttachInfo attachInfo, int xoff, int yoff, boolean scalingRequired, Rect dirty, Rect surfaceInsets) { final Canvas canvas; // ... // 通过Surface获取的canvas canvas = mSurface.lockCanvas(dirty); // 对canvas做一些初始化操作 // ... // 将canvas传入DecorView的draw进行绘制 mView.draw(canvas); // ... } } 因为ViewGroup没有覆写draw()，所以我们看下View的draw()：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 public class View { public void draw(Canvas canvas) { // ... // 有趣的是，draw的流程在源码中有清晰的注释，我们直接翻译下即可 /* * Draw traversal performs several drawing steps which must be executed * in the appropriate order: * // 绘制背景 * 1. Draw the background // 保存canvas图层为后续淡出做准备（可选） * 2. If necessary, save the canvas\u0026#39; layers to prepare for fading // 绘制内容 * 3. Draw view\u0026#39;s content // 绘制子View * 4. Draw children // 绘制淡出边缘并恢复canvas（可选） * 5. If necessary, draw the fading edges and restore layers // 绘制装饰（比如滚动条） * 6. Draw decorations (scrollbars for instance) */ // Step 1, draw the background, if needed int saveCount; drawBackground(canvas); // skip step 2 \u0026amp; 5 if possible (common case) final int viewFlags = mViewFlags; boolean horizontalEdges = (viewFlags \u0026amp; FADING_EDGE_HORIZONTAL) != 0; boolean verticalEdges = (viewFlags \u0026amp; FADING_EDGE_VERTICAL) != 0; if (!verticalEdges \u0026amp;\u0026amp; !horizontalEdges) { // Step 3, draw the content onDraw(canvas); // Step 4, draw the children dispatchDraw(canvas); drawAutofilledHighlight(canvas); // Overlay is part of the content and draws beneath Foreground if (mOverlay != null \u0026amp;\u0026amp; !mOverlay.isEmpty()) { mOverlay.getOverlayView().dispatchDraw(canvas); } // Step 6, draw decorations (foreground, scrollbars) onDrawForeground(canvas); // Step 7, draw the default focus highlight drawDefaultFocusHighlight(canvas); if (debugDraw()) { debugDrawFocus(canvas); } // we\u0026#39;re done... return; } // ... } } 总结 draw的流程其实挺简单的，传入的canvas参数，最初是从ViewRootImpl中创建的，一直从DecorView传递到子View，都用同一个Canvas对象；\nViewGroup比View多了个dispatchDraw()方法，就是绘制子View，其余都一样。\n绘制背景 绘制内容 绘制子View 绘制装饰 问题 先绘制ViewGroup还是先绘制View？\n答：这个问题就不能简单的像measure和layou那样回答是ViewGroup或者View了，因为看绘制的流程源码，ViewGroup要先绘制背景，绘制内容，然后绘制子View，最后绘制装饰，所以是按照图层来的，比如ListView，先绘制列表的背景色，再绘制子View，就是一个个item，最后绘制滚动条，而滚动条也属于ViewGroup，所以要看具体的ViewGroup是什么。\n如果只是简单的LinearLayout，那确实是先绘制ViewGroup，后绘制View，而ScrollView就不是这样了，因为最后还要绘制LinearLayout。\n","date":"2022-03-28T04:14:54-08:00","permalink":"https://pangfq.github.io/blog/p/android-view-source7/","title":"Activity绘制系列：7. onDraw()"},{"content":"概述 requestLayout()，字面意思是请求布局，那是不是只调用了layout过程呢？具体看下源码便知。\n源码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 public class View implements Drawable.Callback, KeyEvent.Callback, AccessibilityEventSource { public void requestLayout() { if (mMeasureCache != null) mMeasureCache.clear(); if (mAttachInfo != null \u0026amp;\u0026amp; mAttachInfo.mViewRequestingLayout == null) { // Only trigger request-during-layout logic if this is the view requesting it, // not the views in its parent hierarchy // 这里会获取ViewRootImpl对象 ViewRootImpl viewRoot = getViewRootImpl(); // 判断是否正在执行ViewRootImpl的layout操作，如果正在执行，则将请求requestLayout的View放到一个List中，等View树layout结束之后，才会去调用刚才requestLayout的View // 为什么要有这个判断呢？因为在layout()流程中又调用了requestLayout()，如果不加判断，就又会重新走layout()，导致死循环。 if (viewRoot != null \u0026amp;\u0026amp; viewRoot.isInLayout()) { if (!viewRoot.requestLayoutDuringLayout(this)) { return; } } mAttachInfo.mViewRequestingLayout = this; } mPrivateFlags |= PFLAG_FORCE_LAYOUT; mPrivateFlags |= PFLAG_INVALIDATED; if (mParent != null \u0026amp;\u0026amp; !mParent.isLayoutRequested()) { // mParent是一个ViewParent类型的变量，ViewGroup和ViewRootImpl都实现了该接口，所以View中的mParent就是自己的ViewGroup // 子View会调用父View的requestLayout()，如此这般调用，层层向上传递，最终会到ViewRootImpl的requestLayout()中 mParent.requestLayout(); } if (mAttachInfo != null \u0026amp;\u0026amp; mAttachInfo.mViewRequestingLayout == this) { mAttachInfo.mViewRequestingLayout = null; } } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 public final class ViewRootImpl implements ViewParent, View.AttachInfo.Callbacks, ThreadedRenderer.DrawCallbacks { ArrayList\u0026lt;View\u0026gt; mLayoutRequesters = new ArrayList\u0026lt;View\u0026gt;(); // 在layout过程中请求layout boolean requestLayoutDuringLayout(final View view) { // ... // 放到一个ArrayList中 if (!mLayoutRequesters.contains(view)) { mLayoutRequesters.add(view); } // ... } @Override public void requestLayout() { if (!mHandlingLayoutInLayoutRequest) { checkThread(); mLayoutRequested = true; // 这个方法很熟悉吧，内部通过handler，先post一个同步屏障消息，然后再post一个异步消息，触发Activity绘制的三大流程，所以从该方法就可以看出来，调用View的requestLayout()，其实并不是只会触发layout操作，而是触发三大流程 scheduleTraversals(); }\t} private void performLayout(WindowManager.LayoutParams lp, int desiredWindowWidth, int desiredWindowHeight) { // ... // 调用layout()之前，会将标志位置为true mInLayout = true; try { // 开始调用DecorView的layout()，进行View树的layout过程 host.layout(0, 0, host.getMeasuredWidth(), host.getMeasuredHeight()); // 调用layout()之后，会将标志位置为false mInLayout = false; // 到这一步，View树的layout阶段已经执行完成 // 接下来，判断之前在layout()过程中是否有子View调用了requestLayout()重新请求layout // 如果有的话，再依次取出执行requestLayout()方法 // 此处就解释了在View树的layout阶段如果有子View调用了requestLayout()为什么不会出现死循环的原因 int numViewsRequestingLayout = mLayoutRequesters.size(); if (numViewsRequestingLayout \u0026gt; 0) { // requestLayout() was called during layout. // If no layout-request flags are set on the requesting views, there is no problem. // If some requests are still pending, then we need to clear those flags and do // a full request/measure/layout pass to handle this situation. ArrayList\u0026lt;View\u0026gt; validLayoutRequesters = getValidLayoutRequesters(mLayoutRequesters, false); if (validLayoutRequesters != null) { // Set this flag to indicate that any further requests are happening during // the second pass, which may result in posting those requests to the next // frame instead mHandlingLayoutInLayoutRequest = true; // Process fresh layout requests, then measure and layout int numValidRequests = validLayoutRequesters.size(); for (int i = 0; i \u0026lt; numValidRequests; ++i) { final View view = validLayoutRequesters.get(i); Log.w(\u0026#34;View\u0026#34;, \u0026#34;requestLayout() improperly called by \u0026#34; + view + \u0026#34; during layout: running second layout pass\u0026#34;); view.requestLayout(); } measureHierarchy(host, lp, mView.getContext().getResources(), desiredWindowWidth, desiredWindowHeight); mInLayout = true; host.layout(0, 0, host.getMeasuredWidth(), host.getMeasuredHeight()); mHandlingLayoutInLayoutRequest = false; // Check the valid requests again, this time without checking/clearing the // layout flags, since requests happening during the second pass get noop\u0026#39;d validLayoutRequesters = getValidLayoutRequesters(mLayoutRequesters, true); if (validLayoutRequesters != null) { final ArrayList\u0026lt;View\u0026gt; finalRequesters = validLayoutRequesters; // Post second-pass requests to the next frame getRunQueue().post(new Runnable() { @Override public void run() { int numValidRequests = finalRequesters.size(); for (int i = 0; i \u0026lt; numValidRequests; ++i) { final View view = finalRequesters.get(i); Log.w(\u0026#34;View\u0026#34;, \u0026#34;requestLayout() improperly called by \u0026#34; + view + \u0026#34; during second layout pass: posting in next frame\u0026#34;); view.requestLayout(); } } }); } } } } finally { Trace.traceEnd(Trace.TRACE_TAG_VIEW); } mInLayout = false; } } 总结 requestLayout()需要掌握两点：\n会触发整个View树的measure、layout、draw过程，而并非只有layout 如果在View树的layout过程中有子View在其layout()中调用了requestLayout()会不会造成死循环？不会，因为ViewRootImpl会等到View树的layout()执行后才会去调用之前requestLayout()的子View ","date":"2022-03-28T04:14:54-08:00","permalink":"https://pangfq.github.io/blog/p/android-view-source8/","title":"Activity绘制系列：8. requestLayout()"},{"content":"概述 invalidate()，翻译为使无效，使作废，也就是所谓的重新绘制，但具体是重新走三大步中的哪一步还全部呢？\n我们还是来看下源码。\n源码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 public class View implements Drawable.Callback, KeyEvent.Callback, AccessibilityEventSource { public void invalidate() { // 调用了重载方法，并传入参数true invalidate(true); } // 这里的参数invalidateCache表示是否使当前View的缓存失效 // true：使自身缓存失效，意味着View树要全部执行draw流程 // false：不使自身缓存失效，意味着View树，除了自身外，其余都要执行draw流程 public void invalidate(boolean invalidateCache) { invalidateInternal(0, 0, mRight - mLeft, mBottom - mTop, invalidateCache, true); } void invalidateInternal(int l, int t, int r, int b, boolean invalidateCache, boolean fullInvalidate) { if (mGhostView != null) { mGhostView.invalidate(true); return; } // 是否跳过重绘 // 如果当前View不可见或者正在执行动画，就会跳过重绘 if (skipInvalidate()) { return; } // Reset content capture caches mCachedContentCaptureSession = null; // 设置各种标志位，太多了，不一一看了，但可以看出google喜欢用位运算来处理这些标志位 if ((mPrivateFlags \u0026amp; (PFLAG_DRAWN | PFLAG_HAS_BOUNDS)) == (PFLAG_DRAWN | PFLAG_HAS_BOUNDS) || (invalidateCache \u0026amp;\u0026amp; (mPrivateFlags \u0026amp; PFLAG_DRAWING_CACHE_VALID) == PFLAG_DRAWING_CACHE_VALID) || (mPrivateFlags \u0026amp; PFLAG_INVALIDATED) != PFLAG_INVALIDATED || (fullInvalidate \u0026amp;\u0026amp; isOpaque() != mLastIsOpaque)) { if (fullInvalidate) { mLastIsOpaque = isOpaque(); mPrivateFlags \u0026amp;= ~PFLAG_DRAWN; } mPrivateFlags |= PFLAG_DIRTY; if (invalidateCache) { mPrivateFlags |= PFLAG_INVALIDATED; mPrivateFlags \u0026amp;= ~PFLAG_DRAWING_CACHE_VALID; } // Propagate the damage rectangle to the parent view. final AttachInfo ai = mAttachInfo; final ViewParent p = mParent; if (p != null \u0026amp;\u0026amp; ai != null \u0026amp;\u0026amp; l \u0026lt; r \u0026amp;\u0026amp; t \u0026lt; b) { final Rect damage = ai.mTmpInvalRect; damage.set(l, t, r, b); // 调用ViewGroup的invalidateChild() p.invalidateChild(this, damage); } // Damage the entire projection receiver, if necessary. if (mBackground != null \u0026amp;\u0026amp; mBackground.isProjected()) { final View receiver = getProjectionReceiver(); if (receiver != null) { receiver.damageInParent(); } } } } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 public abstract class ViewGroup extends View implements ViewParent, ViewManager { public final void invalidateChild(View child, final Rect dirty) { final AttachInfo attachInfo = mAttachInfo; if (attachInfo != null \u0026amp;\u0026amp; attachInfo.mHardwareAccelerated) { // HW accelerated fast path onDescendantInvalidated(child, child); return; } ViewParent parent = this; if (attachInfo != null) { // If the child is drawing an animation, we want to copy this flag onto // ourselves and the parent to make sure the invalidate request goes // through final boolean drawAnimation = (child.mPrivateFlags \u0026amp; PFLAG_DRAW_ANIMATION) != 0; // Check whether the child that requests the invalidate is fully opaque // Views being animated or transformed are not considered opaque because we may // be invalidating their old position and need the parent to paint behind them. Matrix childMatrix = child.getMatrix(); // Mark the child as dirty, using the appropriate flag // Make sure we do not set both flags at the same time if (child.mLayerType != LAYER_TYPE_NONE) { mPrivateFlags |= PFLAG_INVALIDATED; mPrivateFlags \u0026amp;= ~PFLAG_DRAWING_CACHE_VALID; } final int[] location = attachInfo.mInvalidateChildLocation; location[CHILD_LEFT_INDEX] = child.mLeft; location[CHILD_TOP_INDEX] = child.mTop; if (!childMatrix.isIdentity() || (mGroupFlags \u0026amp; ViewGroup.FLAG_SUPPORT_STATIC_TRANSFORMATIONS) != 0) { RectF boundingRect = attachInfo.mTmpTransformRect; boundingRect.set(dirty); Matrix transformMatrix; if ((mGroupFlags \u0026amp; ViewGroup.FLAG_SUPPORT_STATIC_TRANSFORMATIONS) != 0) { Transformation t = attachInfo.mTmpTransformation; boolean transformed = getChildStaticTransformation(child, t); if (transformed) { transformMatrix = attachInfo.mTmpMatrix; transformMatrix.set(t.getMatrix()); if (!childMatrix.isIdentity()) { transformMatrix.preConcat(childMatrix); } } else { transformMatrix = childMatrix; } } else { transformMatrix = childMatrix; } transformMatrix.mapRect(boundingRect); dirty.set((int) Math.floor(boundingRect.left), (int) Math.floor(boundingRect.top), (int) Math.ceil(boundingRect.right), (int) Math.ceil(boundingRect.bottom)); } do { View view = null; if (parent instanceof View) { view = (View) parent; } if (drawAnimation) { if (view != null) { view.mPrivateFlags |= PFLAG_DRAW_ANIMATION; } else if (parent instanceof ViewRootImpl) { ((ViewRootImpl) parent).mIsAnimating = true; } } // If the parent is dirty opaque or not dirty, mark it dirty with the opaque // flag coming from the child that initiated the invalidate if (view != null) { if ((view.mPrivateFlags \u0026amp; PFLAG_DIRTY_MASK) != PFLAG_DIRTY) { view.mPrivateFlags = (view.mPrivateFlags \u0026amp; ~PFLAG_DIRTY_MASK) | PFLAG_DIRTY; } } // 通过一个do while 循环，层层向上，依次执行父View的invalidateChildInParent() // 最终会到ViewRootImpl#invalidateChildInParent() parent = parent.invalidateChildInParent(location, dirty); if (view != null) { // Account for transform on current parent Matrix m = view.getMatrix(); if (!m.isIdentity()) { RectF boundingRect = attachInfo.mTmpTransformRect; boundingRect.set(dirty); m.mapRect(boundingRect); dirty.set((int) Math.floor(boundingRect.left), (int) Math.floor(boundingRect.top), (int) Math.ceil(boundingRect.right), (int) Math.ceil(boundingRect.bottom)); } } } while (parent != null); } } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 public final class ViewRootImpl implements ViewParent, View.AttachInfo.Callbacks, ThreadedRenderer.DrawCallbacks { @Override public ViewParent invalidateChildInParent(int[] location, Rect dirty) { checkThread(); if (DEBUG_DRAW) Log.v(mTag, \u0026#34;Invalidate child: \u0026#34; + dirty); if (dirty == null) { invalidate(); return null; } else if (dirty.isEmpty() \u0026amp;\u0026amp; !mIsAnimating) { return null; } if (mCurScrollY != 0 || mTranslator != null) { mTempRect.set(dirty); dirty = mTempRect; if (mCurScrollY != 0) { dirty.offset(0, -mCurScrollY); } if (mTranslator != null) { mTranslator.translateRectInAppWindowToScreen(dirty); } if (mAttachInfo.mScalingRequired) { dirty.inset(-1, -1); } } // 看这里 invalidateRectOnScreen(dirty); return null; } private void invalidateRectOnScreen(Rect dirty) { final Rect localDirty = mDirty; // Add the new dirty rect to the current one localDirty.union(dirty.left, dirty.top, dirty.right, dirty.bottom); // Intersect with the bounds of the window to skip // updates that lie outside of the visible region final float appScale = mAttachInfo.mApplicationScale; final boolean intersected = localDirty.intersect(0, 0, (int) (mWidth * appScale + 0.5f), (int) (mHeight * appScale + 0.5f)); if (!intersected) { localDirty.setEmpty(); } if (!mWillDrawSoon \u0026amp;\u0026amp; (intersected || mIsAnimating)) { // 再看这里，应该很熟悉吧，我们在寻找Activity的绘制起点的时候就看到过这个方法 // 那是不是invalide()和requestLayout()一样也会重新走三大流程呢？ // 其实不是，因为invalide()会通过设置各种标志位，ViewRootImpl在调用三大流程时只会执行draw流程，这里就不具体讲解了，看ViewRootImpl#performTraversals()即可 scheduleTraversals(); } } } 总结 invalidate()需要掌握两点：\ninvalidate()只触发了draw流程 并且是自身的draw流程，不是整个View树（如果是View调用，则只触发自身的draw流程，如果是ViewGroup，则触发自身以及子View的draw流程）。 ","date":"2022-03-28T04:14:54-08:00","permalink":"https://pangfq.github.io/blog/p/android-view-source9/","title":"Activity绘制系列：9. invalidate()"},{"content":"概述 资源：使用aapt工具生成R文件，就是资源名与资源id的映射表； 代码：使用javac编译成class文件，再转成dex文件； 未签名的apk：使用ApkBuilder生成未签名的APK文件； 签名：使用JarSigner签名，生成META-INF目录以及里面3个文件，号称签名三兄弟； 打包：使用ZipAlign工具压缩打包。 上述是v1签名打包的流程，如果是v2、v3签名打包，则4和5互换顺序，并且签名使用ApkSigner工具，因为v2、v3是对ZIP进行签名的，所以要先打成ZIP包后进行签名，并将签名信息写入到ZIP的某个块中。\n","date":"2022-03-28T04:14:54-08:00","permalink":"https://pangfq.github.io/blog/p/android-apk_pkg/","title":"APK打包流程"},{"content":"概述 APK瘦身，主要分为两个方面：代码和资源。\n代码 代码方面的精简，需要具体代码具体分析，而且精简效果不明显，目前总结如下：\n移除未使用的代码，比如： 多余的import语句 没有被调用到的方法或属性 开启代码混淆； 实体类别用set、get方法，直接用public修饰属性； 合并一些功能相同的类，比如： 有很多工具类中的功能有重叠等 通过代码重构解决代码冗余问题，比如： 使用三目运算符代替if-else 减少临时变量的定义 资源 资源方面的精简，涉及的东西较多，而且精简效果很明显，如下：\n图片资源的精简，比如：\n压缩质量，使用TinyPng、智图等工具对图片进行适当压缩； 选择合适的图片格式，比如：没有透明通道的就用JPEG格式、简单的图标就用SVG格式、也可以用webP代替JPEG、PNG等； 选择合适的图片尺寸，比如：让设计师按照xxhdpi规格来设计和切图，别小View用大图，那就浪费了； 尽量使用drawable xml、color、.9.png来代替图片； Native库的精简，比如：\n把不支持的CPU架构的Native库都移除，比如：对于一般的手机APP来讲，x86、x86_64、mips这些都可以移除 减少语言支持\nv7包中支持的语言有80种，但一般APP只在一个或者少数几个国家发布，所以只要留下相应国家的语言支持即可，这个在build.gradle中配置APP支持的语言即可，这样大概减少5M\n1 2 3 defaultConfig { resConfigs \u0026#34;zh-rCN\u0026#34;, \u0026#34;zh-rHK\u0026#34;, \u0026#34;zh-rTW\u0026#34;, \u0026#34;en\u0026#34; } 资源名混淆\n使用微信开源的AndResGuard将资源名重命名为简短的名称，并最后使用7zip打包进一步减小APK\n1 gradle resguard[buildType][productFlavor] 原理概述：apk包中有一个resources.arsc文件，该文件保存着apk中所有资源id与资源路径的映射关系，但由于资源路径、资源命名过长，导致resources.arsc文件较大，如果将过长的命名改的简短些，就可以降低该文件的大小，从而达到精简apk的目的\n保留mapping文件：跟代码混淆一样，会生成源资源文件名 和 混淆后的资源文件名的 mapping文件，该文件还是有用的，比如app如有接入热修复框架，那么需要热修复某资源的时候，就要将该资源命名为混淆后的名称\n总结 APK精简分为代码和资源两个方面，对于整个APK来讲，资源精简的效果是最明显的，属于事半功倍类型，但代码精简效果就差了很多，属于出力不讨好类型，但对于个人的代码重构优化能力的提升还是很有帮助的。\n","date":"2022-03-28T04:14:54-08:00","permalink":"https://pangfq.github.io/blog/p/android-minify/","title":"APK瘦身"},{"content":"概述 MultiDex，是Android官方出的，一个用来解决Dalvik无法运行大型项目问题的方案。\n先来看下MultiDex产生的历史背景，其实就是Dalvik为什么无法运行大型项目。\n历史背景 在Dalvik虚拟机时代，由于Google的短视，在设计Dalvik虚拟机的时候，没有想到有朝一日，一个APK中的dex会如此之大，导致Dalvik虚拟机无法加载大型项目，具体表现为以下3点：\n只能加载一个dex文件 单个dex文件中的方法数不能超过65536（方法数超限） 单个dex文件中的方法占用内存不能超过指定内存（LinearAlloc，线性内存超限） 方法数超限 Dalvik在首次加载apk中的dex的时候，会使用dexopt工具对dex进行优化，优化过程中会使用short类型的字段索引dex中的方法数，short是2个字节，2^16=65536，所以这也是为什么单个dex中的方法数不能超过65536的原因。\n线性内存超限 和方法数超限的问题一样，都是发生在dexopt过程，会使用LinearAlloc来缓存dex中的方法信息，LinearAlloc是一个固定的缓存区（Android4.0之前是4M，Android4.0之后是8M或16M），所以可能在方法数还未达到65536就已经超过线性内存了。\n解决方案 Android官方出了一个Multidex的方案，就是多个dex的意思，大概是在打包apk的时候，判断dex中的方法数是否超过65536，如果超了则对dex进行拆分，拆分成一个主dex和多个分dex，会把直接引用放在主dex中，间接引用放在分dex中，并让主dex调用分dex。\n你会有疑问，上述解决方案只能解决65536方法数的问题，那LinearAlloc的问题如何解决呢？\nLinearAlloc的问题一般出现在低端机型，比如Android4.0之前的机型，其LinearAlloc线性内存缓存大小才4M，所以非常容易出现线性内存的问题，如果想要适配低端机型，可以指定dex方法数来进一步降低方法数，比如你可以设置成40000，表示方法数不能超过40000。\n下面是相关代码与Gradle配置：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 // 1. 在app模块的build.gradle中配置开启multidex android { defaultConfig { multiDexEnabled true } // 以下可选，用来配置dex方法数，解决低端机型的LinearAlloc问题 afterEvaluate { tasks.matching { it.name.startsWith(\u0026#39;dex\u0026#39;) }.each { dx -\u0026gt; if (dx.additionalParameters == null) { dx.additionalParameters = [] } // 设置每一个dex的方法数不超过48000，占用内存不超过4M，即可保证不在2.3的低端机型上出现线性内存的限制 dx.additionalParameters += \u0026#39;--set-max-idx-number=48000\u0026#39; // --main-dex-list= 参数是一个类列表的文件，在该文件中的类会被打包在第一个 dex 中。 // multidex.keep 里面列上需要打包到第一个 dex 的 class 文件，注意，如果需要混淆的话需要写混淆之后的 class 。 dx.additionalParameters += \u0026#34;--main-dex-list=$projectDir/multidex.keep\u0026#34;.toString() } } } // 2. 添加依赖 dependencies { implementation \u0026#39;androidx.multidex:multidex:2.0.1\u0026#39; } 1 2 3 4 5 6 7 8 9 10 11 // 3. 自定义Application继承MultidexApplication class App : MultiDexApplication() { @Override protected void attachBaseContext(Context base) { super.attachBaseContext(base); // 除了直接继承MultidexApplication外，还可以自己覆写attachBaseContext()方法，并自行调用MultiDex.install(this); // MultiDex.install(this); } } 相关问题 ART有这个问题吗？ 答：没有。\n因为ART虚拟机，在安装APK时，不需要用到Dex2Opt工具，所以就不存在上述问题。\nART虚拟机会扫描所有Dex文件，并将它们编译为一个后缀名为.oat的机器码文件。\nDalvik为什么要进行Dex2Opt？ 答：因为Dalvik加载dex时，会用到很多依赖，Dex2Opt的过程，就是将这些依赖提前都准备好，并和dex一同打包成.odex文件，这是一种空间换时间来提高加载效率的方式。\nDex2Opt的时机是什么？ 答：有两个时机：\n安装APK的时候，对主dex进行opt 首次运行APP的时候，在Application中执行MultiDex.install(this)，是对其余dex进行opt ","date":"2022-03-28T04:14:54-08:00","permalink":"https://pangfq.github.io/blog/p/android-multidex/","title":"MultiDex"},{"content":"概述 马赛克，音译自Mosaic，原义为镶嵌、镶嵌图案、镶嵌工艺。\n马赛克，可以指一种手段或手法，也可以指使用一块一块材料组合拼接制作的艺术品、装饰品等。\n发源于古希腊。\n由来 早期希腊人最常用黑色和白色来相互搭配，并且只有权威统治者以及有钱人才请得起工匠，购得起材料来表现此奢侈的艺术。\n发展到晚期的希腊马赛克，艺术家为了更多元化地丰富作品，他们开始需要更小的碎石片，并自己切割小石头来完成一幅马赛克。\n到了罗马时期，马赛克已经非常普遍了，一般民宅及公共建筑地板、墙面都用它来装饰，这使得当时的罗马显得多么富裕，使得古罗马建筑豪华到了不可思议的程度。\n引申义 现在说起马赛克，指的是一种图片或视频的处理手段，使其局部模糊，因为这种模糊看上去有一个个的小格子组成，便形象地称这种画面为马赛克。\n拓展知识 我们知道最早流行的浏览器叫网景，Netspace，但我们不知道的是，网景浏览器的前身叫Mosaic，Mosaic浏览器最开始是在伊利诺伊大学发布的，因为属于大学的资产，所以开发团队出来后又重新开发了一套代码，并取名Netspace，其实Mosaic才是互联网史上最早流行的浏览器。\n在其他行业，也有以Mosaic命名的品牌，比如服装行业、陶瓷行业等。\n","date":"2022-03-28T04:14:54-08:00","permalink":"https://pangfq.github.io/blog/p/android-mosaic/","title":"马赛克"},{"content":"概述 在APK打包过程中会进行签名，在APK安装过程中Android系统会验证签名，\n另外还有使用加固工具加固、打多渠道包等等都会涉及到签名，所以很有必要来了解下APK的签名机制。\n在了解APK签名机制之前，先来看下为什么要对APK签名？\n为什么要签名 这个问题其实就是数字签名的作用，当然首先需要了解什么是数字签名，这个我们就不具体讲了，直接来看数字签名的作用，数字签名的作用是两点：\n验证数据的真实性\n就是验证数据发送方是不是我们希望的发送方\n验证数据的完整性\n就是数据发送过来后有没有被篡改\n对于APK的签名来讲，数据的实体就是APK，那APK的签名作用同样也是两点：\n验证APK的真实性\n就是保证开发者发布的APK不被别人冒名顶替，应用市场的类似“洗白白”功能就是通过验证APK的真实性来实现的；\n验证APK的完整性\n就是保证APK发布之后不被别人篡改APK的内容\n上述就是为什么要对APK进行签名的原因。\n签名方案 到目前为止，Android的签名机制已经迭代了3个版本：\nv1，基于JAR签名 v2，APK签名方案，在Android7.0引入 v3，APK签名方案，在Android9.0引入 可以看到v1是基于JAR的签名方案，而v2、v3都是基于APK的签名方案，只是v3比v2多了新功能，但整体没大改。\nv1 解压一个使用v1签名后的APK包后，里面有一个META-INF目录，该目录下有3个文件：\nMANIFEST.MF CERT.SF CERT.RSA 这就是v1签名过程生成的3个文件，姑且称之为“签名三兄弟”吧（让我想到了coco的奶茶三兄弟：布丁、仙草、珍珠），下面是v1签名流程图（来自网络）：\n使用SHA1算法对APK中的每个文件生成摘要\n将每个文件名和其摘要的Base64编码，都保存到MANIFEST.MF文件中\n使用SHA1算法对MANIFEST.MF文件二次摘要\n将二次摘要保存到CERT.SF文件\n使用签名文件中的私钥对CERT.SF的摘要进行签名\n将签名、证书（公钥）保存到CERT.RSA文件\n将三个文件保存到META-INF目录中\n这几步都是有用的，假如有人篡改了APK中的某个文件，那在安装APK时校验这个文件对相应的SHA1值就知道有没有篡改过了；\n那假如篡改完某个文件后，又把该文件对应的SHA1也改成篡改后的SHA1是不是就可以了？不行，因为其所在的MANIFEST.MF文件的摘要没变的话也可以被检查出来；\n那把其所在文件MANIFEST.MF文件的摘要也给改了是不是就可以了？对不起，还是不行。因为MANIFEST.MF文件的摘要是保存在CERT.SF文件中的，并且最后用开发者的私钥对CERT.SF文件进行了加密，也就是签名，篡改者因为没有开发者的私钥，篡改MANIFEST.MF文件的摘要之后，因为无法继续篡改签名而最终导致安装失败。\n那要是用篡改者自己生成的私钥来进行签名的话，是不是就可以了呢？确实可以签名成功，但是如果包名不变的话，即使发布到应用市场，也无法通过市场的“洗白白”功能，该功能就是通过和APP官网的APK的签名摘要进行对比从而识别出山寨APP；\n那如果把包名改了呢？够狠的，把人家包名和签名都改了，那就成二次打包了，不劳无获，真可耻。\n这个也是有办法解决的，就是在启动APP后校验该APP的签名摘要是否与真实签名摘要是否一致，如果不一致则直接闪退。\n当然你可能还会想到，假如通过反编译把这段代码注释掉呢？这个就属于安全领域的问题，咱这里就不讨论下去了。\nv2 v2的出现是为了解决v1中存在的问题的，我们看下v1签名存在哪些问题：\n签名校验耗时严重\n因为v1会对所有文件计算SHA1摘要，所以耗时严重\n完整性校验不强\n因为v1只会对APK中部分文件进行摘要和签名，并不是所有的文件，假如往APK中增加一些文件是不会影响签名的\nv2签名的原理不是给APK内部的文件进行摘要和签名的，而是把APK当成一个ZIP文件来处理，ZIP文件结构：\nZIP内容 ZIP中央目录 ZIP中央目录结尾 首先把ZIP内容按照每1M的大小进行分块计算摘要，然后把这些摘要用签名文件的私钥进行签名，最后连同签名文件的证书（包含公钥）写到ZIP内容块之后，ZIP中央目录块之前的位置，作为APK签名块。\n这样就能保证即使在APK中新增了文件也会导致签名发生变化从而校验失败；另外因为是按照ZIP内容每1M进行计算摘要的，计算时间大大缩短，从而解决了v1中校验耗时的问题。\nv3 v3是在v2的基础上增加了支持签名升级的功能，这里就不展开讲了，有兴趣的自行查阅。\n相关问题 为APP申请微博、微信等开放平台的一些能力的时候，平台会要求填入该APP的应用签名，这个应用签名指的是什么？\n答：一看应用签名，是不是上述说的使用签名文件的私钥对APK摘要进行加密后的密文（签名）呢？\n其实不是，如果是的话，那每次APP升级都得修改平台上的“签名”了。事实上，平台说的“应用签名”指的是证书的摘要，所以可以用java命令从签名文件中获取，也可以从APK中获取。\n下图（来自网络）是java命令获取的证书指纹（摘要），就是所谓的“应用签名”：\n参考 https://zhuanlan.zhihu.com/p/130394904\n","date":"2022-03-28T04:14:54-08:00","permalink":"https://pangfq.github.io/blog/p/android-sign/","title":"签名机制"},{"content":"概述 矢量图和位图，并不是具体的图片格式，而是两种截然不同的构图理论，并且两者是有本质区别的。\n就好比JPA、Restful API各种规范，或者MVC、MVP、MVVM各种模式，其实就是一种思想或者理论，并不是具体的实现。\n什么是位图 位图，Bitmap，其构图理论为像素点，把位图放大后可以看到是由一个一个的方格子组成的，这些方格子就是像素点，每个点由ARGB表示就是PNG格式，每个点由RGB表示就是JPEG格式。\n因为是由一个个像素点构成的，所以其表现能力很强，可以真实地还原现实中绝大部分场景，拍照得到的图片就是位图。\n因为位图是由像素点构成的，所以其大小依赖于分辨率的大小，分辨率越大图片越大；另外图片质量越高图片也越大，所谓质量好坏的意思就是你用几个字节表示像素点。\n什么是矢量图 矢量图， Vector Graphics，其构图理论为数学公式，本质上是很多数学公式的计算指令来表示的，比如点、直线、曲线、圆等，再加上颜色值。\n所以可以看出矢量图的表现能力很有限，只能描述一些基本的图案，比如箭头图标等。\n因为矢量图是由数学公式构成的，所以其大小几乎是固定的，放大无非是改下位置或者尺寸的值而已。\nSVG是矢量图的一种具体实现，你会发现，其文件可以用文本编辑器打开，内容为xml。\n相关问题 既然矢量图的本质是数学公式，那为啥还能在电脑屏幕上显示出来呢？屏幕是由像素点构成的啊\n答：这其实没办法，不能因为屏幕是像素点构成的，就说明矢量图也是由像素点构成的，我们在屏幕上看到的矢量图其实是转换过之后的。另外矢量图并非只能用屏幕来显示，也可以打印出来，比如打印到相片上等等。\n矢量图和位图能相互转换吗？\n答：可以，但得看情况。由两者构图理论的不同得知，任意矢量图都可以转换成位图，但只有简单的位图才能转换成矢量图。简单的含义就是可以由数学公式计算出来的就能转换，否则就不能。\n","date":"2022-03-28T04:14:54-08:00","permalink":"https://pangfq.github.io/blog/p/android-bmp-svg/","title":"矢量图与位图"},{"content":"什么是序列化 你可能张口就来：把对象转成二进制数据的过程。\n回答的没错，但对象在内存中也是按照二进制格式存储的，也就是说把二进制转成了二进制，既然都是二进制为啥还要转呢？\n所以，这个说法还是不够严谨。\n其实，虽然转换前和转换后都是二进制数据，但表现出来的结果是不一样的，或者说二进制数据的组织规则是不一样的。\n那序列化的本质是什么呢？回答这个问题，要从为什么要序列化讲起，而回答为什么要序列化，就要先了解序列化的场景有哪些，这样通过反向推导来得出序列化的本质。\n下面我们一个个来讲。\n序列化的场景 一共有三种场景：\n网络传输 持久化到本地 进程间通信 网络传输 网络分为有线网络和无线网络两种，我们来看下数据在有线网络和无线网络中是如何传播的。\n有线网络分为电线和光纤。 电线是通过电压来控制信号，高电压表示1，低电压表示0，其材质是铜等金属，因为金属可以导电；\n光纤是通过光来控制信号，强光表示1，弱光表示0，其材质是玻璃，因为玻璃可以折射光线。\n无线网络 无线网络是通过无线电波控制控制信号的，这些信号又分为模拟信号和数字信号两种。\n模拟信号是幅度随时间的变化而连续变化的信号；\n数字信号是幅度随时间的变化而离散（跳跃）变化的信号；（需要强调的是，数字信号指的是二值信号，就是只有两种幅度的无线电信号，这样就可以用来表示0和1）\n关键是理解连续和离散的区别，这里有个比喻方便记忆：\n可以把模拟信号想象成手指在手机屏幕上滑动的过程（连续）；\n可以把数字信号想象成手指在手机屏幕上点击的过程（离散）。\n模拟信号的优点是能最大程度的还原真实信息，缺点是容易受到外界的干扰，并且无法加密；\n数字信号的优点是不容易受到外界的干扰，并且可以加密，缺点是失真严重。\n广播用的是模拟信号；\nWIFI用的是数字信号；\n所以，无论是有线网络还是无线网络，最终都是通过使用两种信号来传输二进制数据的。\n持久化到本地 持久化到本地，这里的本地指的是计算机，因为CPU只能处理0和1，也就是二进制格式的数据。\n所以，无论是视频、音频还是图片、文字等信息，最终都是以二进制数据的格式存储在计算机中的，包括CPU的高速缓存、主存内存条、硬盘等所有的存储设备。\n进程间通信 涉及的知识点比较多，具体查看【IPC机制】章节。\n直接说结论，进程间传递的数据也是该数据的二进制序列。\n接下来就可以回答为什么要进行序列化了。\n为什么要序列化 从上面序列化的场景来看，想将一个对象进行网络传输、持久化到本地、进程间通信，都需要先序列化成二进制序列，但对象在内存中本来就是二进制的格式，直接取出来进行传输不行吗？非得进行序列化才能传输？\n答：不行。\n有两个原因：\n对象在内存中的二进制数据不是跨平台的\n因为对象在各个平台中的内存模型是不一样的，比如存储一个User对象，User对象有两个属性name和age，在Java平台和Python平台的内存模型中对User对象在内存中的组织规则大不相同，所以根本不可能从各自平台的内存中直接取出进行传输，这样传输过去的二进制序列，对方平台是不认的。\n所以，为什么要序列化，就和为什么要学习普通话一个道理。\n对象在内存中的二进制数据不是连续的，不是一个整体，是分散的\n因为要进行传输，首先要放在一起，形成一个整体才能传输，就好比搬家前要先把东西都搬到车上然后一起出发，总不能放一件东西车就出发吧。\n所以序列化就是把对象转化成一种跨平台识别的字节格式并打包到一块儿的过程，这样其他平台也能够解析并还原成对象。\n序列化的本质 所以序列化的本质，就是将对象转化成【可传输】的字节序列的过程。\n关键字是：可传输。\n可传输有两个含义：跨平台和整体。\n要达成跨平台，就要有一定的转换规则，这样序列化后才能反序列化成功。\n要达成整体，就要打包到一块儿，这样才更容易传输。\n以后有人问到序列化是什么？千万别回答序列化是将对象转化成二进制序列的过程，而要在二进制前面加上一个限定词：可传输，这样更严谨，也更专业。\n序列化的方式 序列化的方式其实就是一种转换规则，常见的有：\nJSON XML Protobuff JDK等平台自有的序列化 注意事项 static属性不会被序列化\n因为static修饰的属性属于类，不属于对象，而序列化是针对对象而言的，所以static属性不会被序列化。\ntransient属性不会被序列化\n因为transient关键字是专门用在序列化中修饰对象中不想被序列化的属性的。\nserialVersionUID序列化版本号的使用\n就是用来标记序列化对象时的版本的，只有版本号一致，才能反序列化成功。\n即使属性没变，但序列化版本号不一样，反序列化也会失败；\n如果只是新增了属性，但序列化版本号没变，则反序列化可以成功，只是新增的属性获取不到而已。\n","date":"2022-03-28T04:14:54-08:00","permalink":"https://pangfq.github.io/blog/p/android-mosaic/","title":"序列化"},{"content":"2021-10-02 第一次与你见面，是在你家，我俩的缘分从此开始；\n2021-10-07 第一次与你约会，是在清徐文婷饭店吃的沾片子，下午去了太原古县城玩；\n2021-10-16 第一次与你爬山，是在太原的崛围山；\n2021-10-23 第一次将各自的手机换成情侣锁屏，我是米奇，你是米妮；\n2021-11-07 第一次送我礼物，是两件你亲手织的针织礼物，一只可爱的羊，和一颗带有521的篮球；\n2021-11-07 第一次与你逛钟楼街、食品街，我们抓了20次娃娃，一次都没抓到；\n2021-11-11 天气渐冷，你送了我一双皮手套，里面还有张卡片，上面写着“去见你的路上，阳光温柔，云多可爱”；\n2021-12-04 第一次与你滑雪，是在九龙滑雪场，你摔倒很多次，还是没有学会，哈哈；\n2021-12-06 我发了520红包向你表白，正式确定了关系；\n2021-12-10 你给我买了件毛衣，毛衣前面有一只有点幼稚但却很可爱的加菲猫，质量很好；\n2021-12-25 圣诞节这天，收到了你的圣诞礼物，是一个装了苹果、橙子、巧克力的盒子，里面同样有一张卡片，文字太多，我第一次看完没看懂，哈哈；\n2021-12-30 你给我买了件元旦订婚时穿的T恤，还发了顺丰快递；\n2022-01-01 提亲，你家的饭菜太可口了，色香味俱全，竟然有驴板肠；下午我们一起去买金戒指，看了很多，你最后选择的这款，好看又大气；\n2022-01-02 订婚，在亲朋好友的见证下，我们订婚啦，我俩拍的照片看上去都有点紧张，毕竟第一次；\n2022-01-03 在送我进太原南站的路上，我们第一次正式牵手，你的手指纤细修长，就像古诗中说的指如削葱根似的；\n2022-01-16 今天我们把婚纱摄影的事情敲定了，北京秉梵，正月初八。你看这些看了很长时间，海南的、太原的、北京的，各种咨询对比砍价，辛苦你了，就像秉梵销售说的：“你真是太细心了，你老公娶到你真的是太有福气了！”，哈哈；\n","date":"2021-10-02T18:55:20-08:00","permalink":"https://pangfq.github.io/blog/p/love-wife-2021100200/","title":"与你在一起的日子"},{"content":"概述 CAS，Compare And Swap，直译为比较并替换，是JDK提供的非阻塞原子性操作。\n位于java.util.concurrent.atomic包下，例如：AtomicInteger、AtomicBoolean、AtomicLong等等。\n原理 给变量赋值之前，先从内存中取出最新的值，与之前旧值进行比较，如果一致则更新；如果不一致则重新计算结果，并重复刚才的比较操作，这个操作叫CAS的”自旋“操作。\n源码 1 2 3 4 5 6 7 8 9 public class AtomicInteger extends Number implements java.io.Serializable { private static final sun.misc.Unsafe U = sun.misc.Unsafe.getUnsafe(); public final int incrementAndGet() { return U.getAndAddInt(this, VALUE, 1) + 1; } } 内部是通过JDK的sun.misc.Unsafe类来实现CAS操作，sun.misc.Unsafe是JDK内部工具类，从名字上就可以看出，该类对于Java层来讲是”不安全“的，只能通过反射的方式调用。\nABA问题 CAS操作会有ABA问题，就是把一个变量的值从A更新到B再更新回A时，无法确定变量是否有被更新过的问题。\n如何解决？\n通过版本号控制的方式来区分，就是每次更新都会改变版本号，这样即使变量的值被更新成相同的值但因为版本号不同也可以区分出来。\n","date":"2021-02-08T19:11:20-08:00","permalink":"https://pangfq.github.io/blog/p/java-cas/","title":"Java中的CAS机制"},{"content":"概述 volatile，Java中的关键字，用于修饰变量，中文表示不稳定的，易变的意思。\n作用 volatile有两个作用：\n保证并发编程下的内存可见性 保证并发编程下的代码有序性，禁止指令重排优化 保证并发编程下的程序可见性 可见性，表示一个线程修改了某个变量，则其他线程可以立即同步\n因为在多核CPU中，每个核心都有各自的高速缓存，分别是一级和二级，其实还有第三级，但第三级是共享的高速缓存\nCPU在进行运算的时候，先从一级缓存中取数据，没有再去二级缓存中，还没有则取三级缓存，如果三级缓存中也没有的话才会到主存中取\n对应的写操作同理，也是先写到高速缓存最后才同步到主存\n所以，在并发编程中就会出现数据不同步的问题，比如，在一个两核心的CPU中，线程A在核心a中运行，将初始值为0的变量i加1后更新到自己的高速缓存中，此时的变量i=1；线程B在核心b中运行，同样执行i+1操作，但由于主存中的变量i仍然是0，得到的i=1，所以这样就造成了并发编程下的可见性问题，其实就是数据不同步的问题\n被volatile修饰的变量表示每次读写都会到主存中，这样可以保证数据的可见性（一致性）\n保证并发编程下的程序有序性，禁止指令重排优化 什么是指令重排？\n计算机在执行程序时，为了最大化地提高CPU内部各种计算单元的利用率，常常对所要执行的指令（程序）做重排优化\n当然这个指令重排对于单线程不会有影响，但在多线程情况下会导致有序性的问题\n这个问题就是，在多线程编程情况下，可能会出现得到的实际对象为null的问题。\n比如：在double check写法的单例模式下，线程A执行了new操作，但由于指令重排的存在，可能会导致线程B在获取实例的时候该实例变量不为null，但实际指向的对象还未初始化的情况，造成线程B得到一个变量不为null，但实际指向的对象却是null的情况。\n相关问题 一个int变量用volatile修饰后能保证并发编程下的线程安全吗？\n答：不能。因为volatile可以实现并发编程下的两个特性，一个是可见性，一个是有序性，但无法实现操作的原子性，也就是如果这个操作不是原子性的，比如i++就无法保证并发编程下的线程安全。\n","date":"2021-02-05T18:55:20-08:00","permalink":"https://pangfq.github.io/blog/p/java-volatile/","title":"volatile关键字的作用"},{"content":"概述 Binder是Android中实现IPC（RPC）的API，学习API的使用并不复杂，但底层的原理也要了解。\n在了解Binder的底层原理之前，先看看传统的IPC是如何实现的。\n传统IPC原理 进程间的内存空间是相互隔离的，那两者如何通信呢？\n这个有点像Android中，两个模块相互解耦，没有任何依赖，但想要实现两模块间的通信一样。解决方法就是引入一个基础模块，让两模块都依赖它，通过这个基础模块来充当两模块间通信的桥梁。\n其实传统IPC的实现跟这个类似，也是通过一个基础模块，叫内核空间（Kernel Space），而APP进程叫作用户空间（User Space）。\n具体是先将发送方进程的数据拷贝到内核空间，然后再将数据从内核空间拷贝到接收方进程中。\n可以看到，传统的IPC方式，通过两次内存拷贝才实现数据传递的，效率有点低。\n而Android中的Binder只有一次拷贝，大大提升了性能，这也为什么Android没有直接用Linux中的IPC机制，而是自己重新实现的原因。\nBinder原理 首先需要了解Linux的一个知识点：【内存映射】。\n简单讲，就是将用户空间的一块内存区域映射到内核空间。\n映射关系建立后，用户对这块内存区域的修改可以直接反应到内核空间，反之内核空间对这段区域的修改也能直接反应到用户区域。\nLinux中的内存映射是通过mmap()实现的。\n一次完整的BinderIPC操作是这样的：\n首先Binder驱动在内核空间创建一个数据接收缓存区； 建立接收方进程的用户空间地址和在内核空间创建的数据缓存区的映射关系； 发送方进程通过系统调用copy_from_user()将数据拷贝到内核的数据接收缓存区，由于内核缓存区和接收方进程的用户空间已经建立了映射关系，所以就相当于把数据拷贝到了接收方进程的内存空间。 所以Android中的Binder相比传统的IPC方式，少了一次拷贝，大大提高了性能。\nBinder架构 Binder机制是基于C/S架构的，其中定义了4个角色：\nClient Server Binder驱动 ServiceManager Binder实现 除了底层原理与传统IPC不一样之外，在实现上也不一样。\nBinder使用了面向对象的思想来实现IPC调用，就好像一个进程中对象之间的相互调用似的。\n具体是Client通过Server提供的Binder引用来访问Server，同样的，Server通过Client提供的Binder引用来访问Client。\n注意事项 为什么通过Binder传输的数据要进行序列化？\n答：Binder传输其实底层是跨进程通信，虽然在同一个平台，没有跨平台的要求，但涉及到了不同的进程，进程间的内存单元是相互隔离的，Binder是通过数据拷贝实现的跨进程通信，所以也是需要将数据打包成一个整体统一进行发送，就像搬家一样，要等东西都装好车才开始搬家，不能每装一件东西就搬家吧，这样效率也太低了。\n","date":"2021-02-04T18:55:20-08:00","permalink":"https://pangfq.github.io/blog/p/android-ipc-binder/","title":"Binder机制"},{"content":"概述 IPC，全称为Inter Process Communication，翻译成中文为进程间通信或者跨进程通信。\n概念不难理解，就是不同进程间的数据交换，或者相互调用，但为啥非要专门强调下进程间的通信呢？你看人家线程就没有线程间通信的说法。\n其实，这个要从进程和线程的概念讲起了。\n什么是进程 进程是内存分配的最小单元。\n什么意思？就是操作系统是按照进程来分配内存单元的，各自进程有各自的内存空间，不同内存单元相互隔离，互不干扰。\n举例来说，有一个全局类Constants，其中定义了一个static类型的count变量，默认值为0，然后有两个Activity，AActivity在a进程，BActivity在b进程，在AActivity中调用Constants.count++;此时count=1，接着启动BActivity，在其onCreate()中打印Constants.count，其值依然为0，并不是1。\n也就是说对于不同的进程，内存级别的数据是无法共享的，因为这个数据在不同进程中完全是两套内存。\n但线程就不存在这种情况，因为属于同一进程，共享该进程下的内存单元，只是需要处理好数据同步的问题而已。\nAndroid中的进程 在Android中，一个APP就是一个单独的进程，这个进程是fork自zygote进程，并带了JVM，当然一个APP也可以创建额外的进程，同样是fork自zygote进程，也同样带了JVM，从不同进程拥有各自的JVM这里，也能看出进程的内存单元也是独立的。\n为什么要开启多进程 一个APP开启多进程，当然是多进程有一些优点是单进程替代不了的。\n突破单进程的内存大小限制\n比如：APP中有比较耗内存的功能模块，为避免OOM，就可以放到子进程中处理\n解决系统组件的内存泄露\n比如：webview组件会造成内存泄露，那么就可以在退出webview的时候把所在的子进程也杀掉，从而解决内存泄露的问题。\n为什么会有IPC 为什么会有跨进程通信呢？各自独立不行吗？\n这个就好比，有人的地方就有江湖一样，人虽然是个体，但却免不了与其他人发生各种各样的关联。\n进程也一样，虽然APP都各自独立，但也免不了依赖别的进程，这些进程可能是其他APP，也可能是系统服务进程，\n比如startActivity()的操作，虽然是启动自己的Activity，但内部用到了ActivityManagerService，该服务是一个系统级的服务，在一个叫SystemServer的进程中。\n也可能让别的APP依赖自己，这种情况可以通过ContentProvidor来对外提供服务，其内部也是基于IPC机制实现的。\n所以，IPC就跟人的社交一样不可或缺。\n","date":"2021-02-04T18:55:20-08:00","permalink":"https://pangfq.github.io/blog/p/android-ipc/","title":"IPC简介"},{"content":"概述 在篮球这项运动中，想要得分，无非就这么几种方式：投篮、上篮、扣篮，而投篮又是这三种方式中最简单高效的方式，因为投篮还有三分，而上篮和扣篮只能得两分，在三分线外你只能选择投篮得分，总不能三分线外就开始上篮或者扣篮吧，强如乔丹也只能从罚球线起跳，还没听说过有谁能从三分线外起跳完成上扣篮的。\n为什么投篮这么重要 从NBA里也能看出端倪，比如字母哥，长手长脚，一身腱子肉，身体素质逆天，连续两届MVP，但到季后赛，尤其是最后关键时刻，就那么几秒就得决定比赛，这么短的时间只能靠投篮完成绝杀，然而字母哥投篮的短板被无限放大，纵有一身力气也使不上劲，无法主宰比赛，因为大家都知道他没篮儿，他离超级巨星就差这么一点儿，这一点儿就是投篮。\n所以，练好投篮才能算是打好篮球，就像学好数理化，才能走遍天下都不怕一样！\n但练好投篮真不是那么容易的，别说NBA的字母哥、西蒙斯了，就看看咱平时球场的人就知道了，投篮好的能有几个，很多打了十几年球的大叔大爷，依然投不好篮，可能两分准，但放三分线外就不准了，因为三分会把投篮的错误姿势放大，导致姿势变形，发不上力，当然投不进去了。\n所以，三分球投的好才能算投篮好。\n那什么才是正确的投篮姿势呢？下面咱们来一起来探索。\n什么才是正确的投篮姿势 所谓正确的投篮姿势，在我看来就是科学的投篮姿势，也就是投篮的时候感觉更容易、更轻松并且命中率更高的姿势。\n整体概念 在讲解之前，首选要有一个整体概念，就是投篮是一个全身的动作，用到身体的多个部位，各个部位的动作都要做到位，连成整体，协调发力，一气呵成，才能更容易、更轻松得命中投篮。\n动作细节 我们先把投篮动作分解成以下四个步骤：\n持球 收球 起球 出球 接下来我们依次分析每个动作的要领。\n持球 双脚 双脚自然站立，网上有教程说要与肩同宽，但我觉得，与肩同宽、比肩宽、比肩窄，其实看自己，自然点就行；\n双脚要一前一后，右脚在前，左脚在后（如果是左撇子，反过来即可），前后间距在一个大拇指的宽度即可；\n双脚稍微呈内八状，注意这里是稍微，内偏的角度不要超过10°，这样力量更容易蓄力。\n双手 双手分为投球手和辅助手。\n辅助手自然张开，因为辅助手只起到辅助的作用，搂着球保证球的弹道不偏即可，不参与投射的发力；\n投球手要稍微刻意张开点，尤其是大拇指，要达到90°，这样可以让球更稳定；\n投球手在球的正面，辅助手在球的侧下方，两手的大拇指所呈角度要超过90°；\n双手持球后，将球置于投球手侧的髋关节处，让腿、球、投篮手在一条直线上，当然这条直线的尽头是篮筐。\n收球 收球就是蓄力的过程，想象一下拉弓，弓弦从直线拉成折线，折的程度越大，蓄的力量也就越大。\n弯腰 这个看自己的情况，一般弯下去3、40°就好了。\n屈膝 这个也是看自己的情况，同样一般弯下去3、40°即可。\n弯腰和屈膝基本上是同步进行。\n起球 踮脚尖 脚后跟随着球的移动慢慢向上，力量集中到脚尖，因为要用脚尖蹬地，力的作用是交互的，这样脚尖才能得到力量；\n挺膝 挺膝的过程，要等力量从脚尖传导至膝盖时，膝盖再挺直；\n挺髋 髋要随着球的移动慢慢挺直，我个人的实践经验是，髋要略微优先于大小臂开始做动作，效果会更好。\n大小臂 双手起球的时候，投球手的大臂和小臂间的角度是固定的，然后以为投球手的肩膀为轴，将球从髋关节移到额头上方一点，投篮手的食指指尖正好触摸到额头即可；\n出球 顶肘 最后力量传导到肩膀，再到大臂，顶肘，力量要先向上；\n压腕 接着到小臂，最后传到投篮手，进行压腕，施加一个向前的力，球从食指和中指间出去，最终完成投篮动作。\n总结 可以把投篮比作拉弓射箭，拉弓的过程就是蓄力的过程，这个过程要把弓弦拉开，特别像投篮收球时的弯腰屈膝，然后瞄准目标，把箭射出去。\n网上也有很多教学把投篮比作拉弓射箭，我当时还没大理解，是后来自己练习投篮姿势的时候，才越发觉得投篮和射箭两者有非常相似的底层逻辑。\n了解了正确的投篮姿势之后，剩下的就是进行大量的练习，直到形成肌肉记忆，这是一个枯燥而漫长的过程。\n最后，附上“中投王”阿兰休斯顿的投篮视频链接，这就是咱的投篮模板，一起加油吧，少年！\n个人注意点 投篮用到了全身多个部位，只要有一个部位做不到位，投篮效果就会打折扣，就是感觉不对，我自己容易犯的错误点是：\n不踮脚尖 不蓄力：蓄力用到了三个身体部位，膝盖、腰、肘，蓄力的动作分别是屈膝、弯腰、收肘 更新：2021-04-24 虽然自己会发力了，但发现球投出去总是偏，问题在于双手持球的时候就出问题了。\n在309练习投篮的时候，有一位大爷过来指导我，说投出去的球要向后拨一下让球倒旋起来，这样更容易进球，而想要倒旋，就得有个拨球的动作，而要能拨球，右手出球时就要正，左手只是辅助。\n顿悟，之前我持球的时候就是歪的，出手也是歪的，从最开始的时候就是错误的，之后的动作哪怕再正确也无济于事。\n这个有点像做事情，如果方向就是错误，后面再怎么努力也是白搭。\n果然，球如人生啊。\n更新：2021-05-22 持球时，肩膀和胳膊要收紧，小臂和大臂要构成90°，保持好姿势后就不要动了，以肩关节为轴心，向上举球，因为在举球的过程中如果动作太多就会造成出球不稳，尤其是3分远距离，动作稍微改变一点，投出去的球就会被放大数倍。\n","date":"2021-02-04T18:55:20-08:00","permalink":"https://pangfq.github.io/blog/p/basketball-shoot/","title":"探索更科学的投篮姿势"},{"content":"概述 在多线程的编程中，首先要掌握的是三个特性：可见性、原子性、有序性，这三个特性是多线程编程的基础，理解了三个特性之后才能理解多线程编程。\n可见性 可见性，指的是内存可见性。\n就是当多线程并发访问内存中的共享变量的时候，一个线程对共享变量的修改，其他线程能够立即看到。\n这个特性出现的前提源于CPU内核中高速缓存的存在引起的。\n由于CPU计算速度远远快于内存条的读取速度，所以不得不在两者之间增加一个缓存，这个缓存就叫高速缓存，位于CPU内部，并且CPU中每个核心都有一个高速缓存。那为什么不直接将内存条全部换成高速缓存呢？因为高速缓存太过昂贵，权衡利弊之下只能如此。\n这也导致多线程编程下出现了可见性问题。\n假如在一个双核CPU中分别运行两个线程A和B，内存中有一个int型变量i，其默认值为1，线程A读取i到自己的高速缓存中，并执行i++，此时i=2，但并没有刷新到内存中。\n接着线程B从内存中读取到的变量i的值依旧是1，这样就导致共享变量在线程间不可见的问题。\n我们后面再讲解决方法。\n原子性 原子性，指的是操作的原子性。\n原子性类似于数据库中的事务操作，要么全部执行，要么全部不执行。\n对于CPU中的操作就是指令，这些指令都是原子性的，而向上到了Java层的操作，就是代码，Java是高级语言，有很强的封装性，可能一个操作包含了多个子操作，比如：i++，这个操作可以分成3个子操作：\n取值：获取i的值 计算：计算i+1的结果 赋值：把结果赋值给i 不是原子性的操作，在多线程编程下就会有问题，因为操作系统可以在任意一步子操作中切走CPU时间片。\n举个例子：两个线程同时对变量进行i++操作，i的默认值为1，当线程A执行到第2步子操作也就是执行了1+1=2这步，已经得到结果了，但还没有赋值给i，操作系统将CPU时间片切到线程B，线程B执行第1步子操作获取i的值，按理讲i=2了，但由于线程A并没有将结果赋值给i导致线程B获取到的i=1，此后线程B执行完所有子操作得到的i=2，而线程A得到的i同样是2，但其实是两个线程都做了i++的操作，理应为3才对，这就是多线程编程下不是原子性操作带来的问题。\n上述也可以类比成在ATM上存钱的过程，比如两个人同时在ATM上用一个账户存钱，原账户为0元，两人同时查询到账户看到显示为0元，然后各自往里面存10万，但一个人存入后还没来得及将账户金额更新，另一个人就存进去了，结果各自存完钱后看到的金额是10万，但其实两个人都存了10万，应该账户上有20万才对。\n有序性 有序性，指的是代码执行的有序性。\nJava为了提高代码的执行效率，会对代码进行重拍优化，当然这个重排并不会影响执行结果。\n下面举个例子：\nObject obj = new Object();\n这是一行创建对象并赋值到变量obj的代码，重排优化之前是这个步骤：\n创建变量obj 创建内存空间得到地址0x111 在该内存空间中初始化对象new Object() 将该内存空间的地址0x111赋值给变量obj 但重排优化之后，3和4的步骤就调换了顺序，也就是先将内存空间的地址赋值给变量obj，然后才初始化内存空间，这就导致在多线程编程下获取到的变量obj的值不为null，但对象却没有初始化的情况，太诡异了。\n","date":"2021-02-04T17:02:20-08:00","permalink":"https://pangfq.github.io/blog/p/java-concurrent-program-3/","title":"并发编程中的三个特性"},{"content":"概述 在驾校学习科目二之前，我是完全没开过车的，连摩托车也没骑过，也没了解过这方面的知识，只骑过电动车和自行车，还玩过卡丁车，所以学习科目二的时候，突然发现怎么汽车不踩油门就能走呢？按照我之前的知识储备，比如电动车，右手拧油门才会走啊，再比如卡丁车，右脚踩油门才会走啊，为什么汽车不踩油门就能走呢？这完全超乎了我的想象，甚至颠覆了我的世界观。\n我记得当时就问了教练这个问题，但教练也没能解释清楚，或者说是因为我当时对车的了解实在太少了，少到根本理解不了教练说的话，所以只能硬着头皮学，教练教啥就做啥，不多想，不然这么点课时是拿不了驾照的。但是这个疑问一直在我脑海中萦绕，直到拿到驾照，过了实习期，对车有了一定了解之后，这个问题也一直存在，所以专门花了点时间把它搞懂，而且也是时候把它搞懂了。\n表面 表面上看，是因为汽车启动之后，发动机会有一个怠速，怠速就是发动机维持平稳运转的最低转速，这个转速，在平路上带来的驱动力比汽车受到的摩擦力大一丢丢，正好可以让汽车平稳而缓慢地行驶。\n这样的速度，在我们找车位停车，或者堵车缓慢蠕动的时候，非常的方便和安全。因为如果没有怠速，完全靠司机踩油门控制的话是很难达到平稳又缓慢的车速的，万一多踩了油门车一下蹿出去就可能发生事故，所以汽车厂商都要提供这种贴心又实用的功能。\n总结一句话，表面是因为体验问题，但其实是有更深层次的原因的。\n本质 这个本质要从发动机是如何产生驱动力的角度来看，发动机其实有两种类型，电机和内燃机，电机就是通过电力作为动力的来源，而内燃机是通过燃料作为动力的来源。\n在早期的时候，汽车的发动机都是内燃机，那时候还不是燃烧汽油或者柴油，而是通过烧煤产生的热量带动气缸做机械运动，从而带动车轮运转的。\n你想想，在那个年代汽车等红绿灯时，如果发动机也停下来的话，再启动一次那得多费劲，咱脑补下这个过程，司机下车，把发动机舱盖打开，然后掏出火柴并划着，最后扔进气缸点燃把煤点燃，要是没点燃那还得再重复刚才的过程，是不是太费劲了，所以即使车停下来，发动机也不能停。\n以上就是汽车为什么不踩油门也能走（怠速）的深层次原因，就是因为汽车的发动机是内燃机，而内燃机启动一次太耗时，所以即使车停下来了，但为了避免发动机频繁启停带来的不必要的麻烦，发动机就维持一个最低转速，保证不熄火即可，因为这个最低转速带来的驱动力刚刚大于汽车受到的阻力，所以就出现了不踩油门也能走的效果。\n总结一句话，本质是因为技术问题。\n相关问题 电动汽车为什么也有怠速？ 答：上述我们刚知道了油车有怠速的本质是因为发动机是内燃机，而内燃机启动一次太耗时，所以就需要怠速来保证发动机不熄火。但电动汽车的发动机是电机，不是内燃机了，为什么还会有怠速呢？其实是因为怠速除了在内燃机时代可以解决频繁启动的耗时问题，还可以在停车或堵车时提供平稳缓慢的车速带来了非常好的用户体验，导致电动车也提供这样的功能。\n所以，总结一句，电动汽车之所以有怠速，不是因为技术原因，而是因为怠速带来的用户体验更好。\n类似的问题也是上面的答案，比如现在的油车启动发动机已经不怎么耗时了，还有自动启停功能，那为啥还有怠速呢？答案也是怠速带来的体验更好，这也是为什么很多人都不喜欢开自动启停的原因。\n","date":"2021-02-03T18:55:20-08:00","permalink":"https://pangfq.github.io/blog/p/car-idling/","title":"汽车为什么不踩油门也能走"},{"content":"什么是内存模型 为了保证并发编程的正确性，包括可见性、有序性、原子性，定义了多线程下读写系统内存的操作==规范==\n所以，内存模型是一个抽象概念，是一种规范\n但为什么会有Java内存模型？\n为什么需要内存模型 我们知道，之所以Java是跨平台的，是因为Java虚拟机的功劳，是Java虚拟机屏蔽了各种硬件和操作系统的访问差异，保证Java程序在各种平台上的运行都能一致\n在这个里面，就有对内存的规范，Java提供了一个内存规范，或者说模型，让不同的操作系统去实现各自的内存访问机制\n总结 Java内存模型，是和Java的并发编程有关\n","date":"2021-02-02T18:55:20-08:00","permalink":"https://pangfq.github.io/blog/p/java-jmm/","title":"Java中的内存模型"},{"content":"概述 元旦开车回家，跑高速时发现油耗怎么也低不下来，大概在6个左右，这要比之前高出1个，我开始以为是没做首保的问题，但后来做了首保之后，发现油耗还是没降下来，当然我比之前驾驶要更加暴力许多，难道是因为我的驾驶方式改变的缘故么！过完年后，正月初八返京，因为天气升温至10℃以上，跑高速时我惊奇地发现，油耗降下来了，降到5个左右，原来油耗增高是天气的原因，那么问题来了：汽车油耗在冬天为什么会更高？\n主要原因 其实，跟我们到了冬天更能吃的道理是一样的，多吃一点饭就能提供更多的能量来抵御冬天的严寒。\n汽车也是一样的，汽车是通过燃烧汽油提供的能量来驱动汽车前进，但是到了冬天，气温骤降，需要额外提供能量来抵御外界的低温才能达到之前的驱动力，这就意味着油耗会增高。\n次要原因 上述是主要原因，而次要原因是胎压会因为热胀冷缩变低，使轮胎跟地面的接触面积增大，导致摩擦力增大，汽车就需要多烧油来抵消掉这部分增加的摩擦力，当然油耗也会增加。\n总结 生活中很多事都是相通的。\n","date":"2021-02-02T18:55:20-08:00","permalink":"https://pangfq.github.io/blog/p/car-oil/","title":"汽车油耗为什么冬天会更高"},{"content":"概述 Http协议的缓存策略，分为了三个版本，每个版本的策略都解决了上个版本出现的问题，所以从这方面来看，Http的缓存策略也不是说一出来就很完善，也是后面慢慢优化出来的。\n第一个版本在Http1.0时期，剩下两个版本都是Http1.1的\nHttp1.0 版本1 客户端请求某资源，服务器返回该资源，并在响应头加上字段：Expires:具体时间，例如：Expires:Thu,31 Dec 2020 23:59:59 GMT，表示该资源的过期时间\n客户端收到该资源后，会把Expires字段也缓存下来，下次再请求相同资源时，会先取出上次请求到资源后缓存的Expires字段，再和客户端当下的时间进行对比，如果当下时间已经超过了过期时间，则重新发起请求，如果没到过期时间，则直接返回缓存（如果缓存还在的话）\n优点就是不用再次发起请求询问服务器缓存是否有效，而缺点也是因为这个原因，完全依赖客户端的时间，那就可能会出现客户端时间不准确的情况，比如客户端修改了本地时间，这样就造成无法准确判断缓存过期时间了；另外服务器返回的Expire字段表示缓存的过期时间，而大多数情况，服务器也不知道资源啥时候过期。\n所以，Http协议有了下面的改进：就是把决定缓存是否有效的权利从客户端移到了服务端\nHttp1.1 版本2 为了解决上述问题，Http1.1新加了：\nCache-Control：响应头字段，缓存策略，no-store(禁止缓存)、no-cache(这里并不是不可以缓存，而是可以缓存，但要先请求服务器验证缓存是否有效。不知道为啥起这个名字，太有误导性了，OkHttp的源码中也有类似说法，说no-cache is misleading)等等 Last-Modify：响应头字段，表示资源最新的修改时间 If-Modify-Since：请求头字段，表示资源如果自指定的时间以来修改过了，服务器就返回新资源，否则返回304状态码，客户端使用缓存即可 所以流程就变成了：\n客户端发起资源请求 服务端下发资源，并在响应头中加入Cache-Control字段告知客户端该资源的缓存策略，以及Last-Modify字段告知该资源的最新修改时间 客户端再次请求该资源时，在请求头中加上If-Modify-Since字段，并将上次返回资源时的响应头字段Last-Modify的时间值赋给If-Modify-Since字段 这样服务端和当下资源最新修改时间对比下，就知道要不要返回资源数据了 这样，缓存是否有效的决定权就从客户端移到了服务器端\n这个思路也是我们在开发类似新闻列表需求时，请求数据有没有更新的思路。\n但这个是有问题的：\nLast-Modify表示的最小粒度是秒，而如果一个资源在一秒内多次修改就无法表示了 只能表示时间变化这一个维度，如果文件内容没变，只是更新了时间 就无法表示了 基于上述两个问题，就出现了第三个版本\n版本3 Http1.1又更新了小版本来优化上述问题，新加入了ETag、If-None-Match头字段\nETag：响应头字段，资源内容的唯一标识，相当于资源的信息摘要，内容变化ETag的值也会跟着变，这样解决了修改时间变化，但内容不变造成的缓存失效问题，节约了流量。格式是字符串，但要放在双引号中，例如： 1 ETag: \u0026#34;1ec5-502264e2ae4c0\u0026#34; If-None-Match: 请求头字段，该字段由客户端发起，带上上次返回资源时的ETag值，这样服务端就可以对比资源最新的ETag值，如果不一样就返回资源数据，否则不返回 If-Match: 这个和If-None-Match正好相反，是一致返回资源，否则不返回。可以了解下，一般不用它 总结 Http的缓存机制，其实就是一些请求头和响应头的字段，理解并记忆即可。\n版本一：Expires字段，表示资源的过期时间 版本二：Cache-Control（no-stroe、no-cache）、Last-Modify（资源上次的更新时间）、If-Modify-Since 版本三：E-Tag、If-None-Match ","date":"2021-02-01T18:55:20-08:00","permalink":"https://pangfq.github.io/blog/p/http-cache/","title":"HTTP的缓存机制"},{"content":"概述 我刚开始接触汽车的时候，可以理解手刹和脚刹的区别（虽然理解的也有问题），但是理解不了为什么自动挡的车有P挡，而手动挡车没有，并且不知道P挡和手刹有什么区别，只知道都是驻车时用的。\n解决上述的疑问，要知道P挡、手刹、脚刹的内部构造，才能彻底理解。\n脚刹 脚刹，就是用脚操作的刹车，正式叫法为行车制动器，意思是在车辆行驶的时候可以用来制动的装置，制动力按比例分配到前后轮上。\n制动是控制或者限制动能的意思，车辆动起来就有动能，刹车就是要车辆停下来，也就是控制动能，简称制动。\n右脚踩下刹车踏板之后，行车电脑会根据踩下刹车踏板的力度以及当前车辆行驶状态（加速、减速、匀速），通过计算将制动力按照一定的比例分配到四个轮胎的刹车卡钳上，卡钳会贴到刹车盘上，通过摩擦生成阻力抵消掉车辆的动能从而使其停下来。\n看完这句话，你应该有个疑问：为什么分配到四个轮胎上的制动力还要按照一定的比例分配呢？\n原因是这样的，不管是前驱车、后驱车、还是四驱车，车辆在不同行驶状态下（加速、减速、匀速），重心是不断转移的，比如刹车时，尤其是高速急刹的情况下，全部的重心的都压在前桥上，人的身体会随之前倾，整个车头的惯性最大，此时前后配重的比列可能是9：1，也就是前轮受到的压力要比后轮受到的压力大很多，如果制动力按照5：5分配，就会导致前轮制动力不足，但后轮制动力有余，甚至出现抱死的情况。\n所以制动力要根据当前车辆状态，也就是前后配重比例，分配到四个轮胎上。\n手刹 手刹，就是用手操作的刹车，正式叫法为驻车制动器，意思是在车辆驻车的时候可以用来制动的装置，制动力只作用于后轮。\n手刹又分为机械手刹和电子手刹，区别就在于一个是用电子元器件控制的，一个是用钢丝控制，另外电子手刹更加智能，它有着独特的动态处置机制，就是在车辆行驶的过程中，如果强行启用电子手刹，行车电脑会当做脚刹执行，也就是制动力会作用到四个轮胎上，但电子手刹在静态的处置机制和机械手刹是一致的。\nP挡 P挡，也称驻车挡，也就是在驻车的时候需要挂的挡位，作用在变速箱上，并且自动挡车型上才有。\n具体是通过一个挂钩（驻车棘爪）卡住变速箱的齿轮，从而达到变速箱锁止的效果。\n那么问题也随之而来：\n为什么要锁住变速箱，不是已经有手刹了么？\n答：因为手刹只作用于后轮，而大部分家用车都是前驱车，所以通过锁住变速箱，从而达到锁住前轮的目的。\n为什么自动挡有P挡，而手动挡没有？\n答：因为自动挡变速箱是通过电力驱动液压来控制离合的，所以驻车时电源断开，那么自动变速箱相当于空挡状态，而手动挡是通过机械控制离合的，即使断电也不影响对变速箱的控制，只要不是挂空挡就能保持变速箱和发动机的直接连接，也是很多文章说的硬连接，这样前轮就间接通过变速箱被发动机锁止了，而自动挡变速箱只能专门增加一个挡位，或者说装置来达到在断电情况下对变速箱的锁止功能。\n手动挡车型虽然没有P挡，但一般在平路驻车的时候，也不需要专门挂到一挡来达到自动挡挂P挡的效果，因为下次开车启动之前担心忘记把挡位挂回到空挡，一般我们停车后会顺势把挡位置为空挡，然后熄火拉手刹，如果是电子手刹的话，直接熄火即可。\n当然如果是在坡道驻车时，也可以根据车头的朝向挂挡，车头向下挂R挡，车头向上挂1挡，这样就达到自动挡车型挂P挡的效果。\n个人认为，自动挡车型增加了P挡在驻车时确实更稳更安全，但其实是因为自动挡车型操作太简单了，所以增加一个P挡刷下存在感而已，你看人家手动挡车型驻车时一般都挂空挡，所以我觉得自动挡的P挡有点鸡肋，P挡的出现反而给很多人造成了困惑，为什么有了手刹还要有P挡？为什么手动挡就没有P挡？等等这些疑问。\n总结 脚刹和手刹都是作用在轮胎的刹车盘上，P挡是作用在变速箱上 手刹作用在后轮，P挡作用在前轮，脚刹作用在前后轮 手刹和P挡是在驻车时用的，脚刹是在行驶中用的 ","date":"2021-02-01T18:55:20-08:00","permalink":"https://pangfq.github.io/blog/p/car-brake/","title":"汽车的P挡、手刹、脚刹有什么区别"},{"content":"写在前面 没几天就过年了，过年大家肯定又是胡吃海塞，体重暴增，所以年前给大家分享一些如何科学减肥的方法，做到心中有数，手中有策，假如年后真胖了也不怕。\n以下内容可不是我自己瞎编的，而是在我认认真真看完一本书（《硬派健身》）之后，又结合自己一年的健身经验总结出来的，希望对大家有所帮助。\n减肥，总体来讲就是两件事：\n管住嘴 迈开腿 你看到这个可能会觉得嗤之以鼻，这也太简单了吧谁不会啊，但别小看它，这里的学问可大了，每一条展开来讲都不是400字就能搞定的，下面我会用尽可能简洁的语言来给大家讲解如何科学地管住嘴和迈开腿。\n管住嘴 这里的管住嘴，不是说让你少吃，而是说让你要有选择地吃，是君子有所吃有所不吃的意思\n具体是：少吃脂肪含量多的食品，比如油炸食品；多吃蔬菜，多吃蛋白质含量高的食品，比如牛肉，鸡胸肉，脱脂牛奶等。\n需要强调的是，如果通过节食减肥，虽然过段时间可能会达到一些效果，但是对自己的身体是有伤害的，主要是肠胃和大脑，而且节食减肥减掉的不仅是脂肪还有肌肉，而肌肉的减少会降低你的基础代谢，会让你的基础代谢变差，通俗点讲就是你会变得更加容易胖，这也就是为啥有的人平时吃不多但也不瘦的原因，是因为Ta的基础代谢差。\n所以赶紧放弃节食减肥的想法吧，不仅反人类还注定要失败！\n迈开腿 此处的迈开腿并不是就让你多走路多跑步，只要练习腿就行了，而是指多运动的意思，主要分为两个内容：\n增肌 减脂 增肌 减脂大家都明白，我减肥肯定减的是脂肪，但为啥要增肌呢？\n首先，肌肉是人体的耗能大户，等量的肌肉要比脂肪消耗的能量要多的多，这也是为什么肌肉多的人基础代谢就好，也就是所谓的怎么吃都不胖的根本原因所在，所以要想彻底减下肥来永不反弹，就需要通过增肌来改变自己的体质\n其次，肌肉的体积要比脂肪小很多，比如同是60kg老王和小明，但一个体脂率30%，一个体脂率15%，体脂率小的那个一定看起来更瘦\n如何增肌？\n主要是无氧运动，因为长时间的有氧运动会减掉肌肉，所以女生的话，建议多做深蹲、平板支撑。但深蹲要注意动作是否正确，深蹲练的是臀部和腿部，紧实大腿的同时美化臀型，但如果动作不到位会导致不仅没有翘臀，腿还会变粗，其动作要领是：膝盖不要超过脚尖。\n对于男生而言，无氧运动就很多了，除了上述的深蹲和平板支撑以外，还可以加上器械，比如借助杠铃、哑铃等，这些也要注意动作是否正确，比如使用杠铃卧推，要感受胸部的发力，而不是胳膊，其动作要领是：1. 上快下慢 2. 胳膊不要打直 3. 沉肩夹胸\n减脂 减脂并不是长时间地做有氧运动，比如每次跑一小时步，虽然可以达到减脂的效果，但同时把肌肉也减没了，我们可不想减肌肉，不然之前的增肌不是白增了嘛！而跑的时间短又达不到减脂的效果。那到底有没有不消耗肌肉的减脂运动呢？\n答案肯定是有。\n如何正确减脂？\n这种不减肌肉的减脂运动就叫做：HIIT，高强度间歇运动，其实是无氧运动和有氧运动的结合。\nHIIT并不是一种有固定动作的运动，而是只要满足高强度、间歇即可。\n可以是跑步、骑车、跳绳，或者健身房经常教的操课，比如郑多燕和insanity\n持续做10~20分钟就能达到HIIT的目的。\n最后 如何科学地管住嘴迈开腿就讲完了，大家只掌握了科学的方法是不够的，还需要坚持下去，养成习惯，这样才能拥有让别人羡慕的好身材。\n","date":"2018-06-05T18:55:20-08:00","permalink":"https://pangfq.github.io/blog/p/reduce-weight/","title":"如何科学地减肥"}]