---
title: 并发编程中的三个特性
slug: work-java-concurrent-program-3
date: 2021-02-04T17:02:20-08:00
categories:
    - Java
tags:
    - 并发编程
---

## 概述

在多线程的编程中，首先要掌握的是三个特性：可见性、原子性、有序性，这三个特性是多线程编程的基础，理解了三个特性之后才能理解多线程编程。

## 可见性

可见性，指的是内存可见性。

就是当多线程并发访问内存中的共享变量的时候，一个线程对共享变量的修改，其他线程能够立即看到。

这个特性出现的前提源于CPU内核中高速缓存的存在引起的。

由于CPU计算速度远远快于内存条的读取速度，所以不得不在两者之间增加一个缓存，这个缓存就叫高速缓存，位于CPU内部，并且CPU中每个核心都有一个高速缓存。那为什么不直接将内存条全部换成高速缓存呢？因为高速缓存太过昂贵，权衡利弊之下只能如此。

这也导致多线程编程下出现了可见性问题。

假如在一个双核CPU中分别运行两个线程A和B，内存中有一个int型变量i，其默认值为1，线程A读取i到自己的高速缓存中，并执行i++，此时i=2，但并没有刷新到内存中。

接着线程B从内存中读取到的变量i的值依旧是1，这样就导致共享变量在线程间不可见的问题。

我们后面再讲解决方法。

## 原子性

原子性，指的是操作的原子性。

原子性类似于数据库中的事务操作，要么全部执行，要么全部不执行。

对于CPU中的操作就是指令，这些指令都是原子性的，而向上到了Java层的操作，就是代码，Java是高级语言，有很强的封装性，可能一个操作包含了多个子操作，比如：i++，这个操作可以分成3个子操作：

1. 取值：获取i的值
2. 计算：计算i+1的结果
3. 赋值：把结果赋值给i

不是原子性的操作，在多线程编程下就会有问题，因为操作系统可以在任意一步子操作中切走CPU时间片。

举个例子：两个线程同时对变量进行i++操作，i的默认值为1，当线程A执行到第2步子操作也就是执行了1+1=2这步，已经得到结果了，但还没有赋值给i，操作系统将CPU时间片切到线程B，线程B执行第1步子操作获取i的值，按理讲i=2了，但由于线程A并没有将结果赋值给i导致线程B获取到的i=1，此后线程B执行完所有子操作得到的i=2，而线程A得到的i同样是2，但其实是两个线程都做了i++的操作，理应为3才对，这就是多线程编程下不是原子性操作带来的问题。

上述也可以类比成在ATM上存钱的过程，比如两个人同时在ATM上用一个账户存钱，原账户为0元，两人同时查询到账户看到显示为0元，然后各自往里面存10万，但一个人存入后还没来得及将账户金额更新，另一个人就存进去了，结果各自存完钱后看到的金额是10万，但其实两个人都存了10万，应该账户上有20万才对。

## 有序性

有序性，指的是代码执行的有序性。

Java为了提高代码的执行效率，会对代码进行重拍优化，当然这个重排并不会影响执行结果。

下面举个例子：

Object obj = new Object();

这是一行创建对象并赋值到变量obj的代码，重排优化之前是这个步骤：

1. 创建变量obj
2. 创建内存空间得到地址0x111
3. 在该内存空间中初始化对象new Object()
4. 将该内存空间的地址0x111赋值给变量obj

但重排优化之后，3和4的步骤就调换了顺序，也就是先将内存空间的地址赋值给变量obj，然后才初始化内存空间，这就导致在多线程编程下获取到的变量obj的值不为null，但对象却没有初始化的情况，太诡异了。

