---
title: volatile关键字的作用
slug: java-volatile
date: 2021-02-05T18:55:20-08:00
categories:
    - Java
tags:
    - volatile
---

## 概述

volatile，Java中的关键字，用于修饰变量，中文表示不稳定的，易变的意思。

## 作用

volatile有两个作用：
1. 保证并发编程下的内存可见性
2. 保证并发编程下的代码有序性，禁止指令重排优化

### 保证并发编程下的程序可见性

可见性，表示一个线程修改了某个变量，则其他线程可以立即同步

因为在多核CPU中，每个核心都有各自的高速缓存，分别是一级和二级，其实还有第三级，但第三级是共享的高速缓存

CPU在进行运算的时候，先从一级缓存中取数据，没有再去二级缓存中，还没有则取三级缓存，如果三级缓存中也没有的话才会到主存中取

对应的写操作同理，也是先写到高速缓存最后才同步到主存

所以，在并发编程中就会出现数据不同步的问题，比如，在一个两核心的CPU中，线程A在核心a中运行，将初始值为0的变量i加1后更新到自己的高速缓存中，此时的变量i=1；线程B在核心b中运行，同样执行i+1操作，但由于主存中的变量i仍然是0，得到的i=1，所以这样就造成了并发编程下的可见性问题，其实就是数据不同步的问题


被volatile修饰的变量表示每次读写都会到主存中，这样可以保证数据的可见性（一致性）

### 保证并发编程下的程序有序性，禁止指令重排优化

什么是指令重排？

计算机在执行程序时，为了最大化地提高CPU内部各种计算单元的利用率，常常对所要执行的指令（程序）做重排优化

当然这个指令重排对于单线程不会有影响，但在多线程情况下会导致有序性的问题

这个问题就是，在多线程编程情况下，可能会出现得到的实际对象为null的问题。

比如：在double check写法的单例模式下，线程A执行了new操作，但由于指令重排的存在，可能会导致线程B在获取实例的时候该实例变量不为null，但实际指向的对象还未初始化的情况，造成线程B得到一个变量不为null，但实际指向的对象却是null的情况。

## 相关问题

一个int变量用volatile修饰后能保证并发编程下的线程安全吗？

答：不能。因为volatile可以实现并发编程下的两个特性，一个是可见性，一个是有序性，但无法实现操作的原子性，也就是如果这个操作不是原子性的，比如i++就无法保证并发编程下的线程安全。