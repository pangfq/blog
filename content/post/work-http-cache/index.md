---
title: HTTP的缓存机制
description: 
slug: work-android-apk_pkg
date: 2021-02-01T18:55:20-08:00
tags:
    - HTTP
---

## 概述

Http协议的缓存策略，分为了三个版本，每个版本的策略都解决了上个版本出现的问题，所以从这方面来看，Http的缓存策略也不是说一出来就很完善，也是后面慢慢优化出来的。

第一个版本在Http1.0时期，剩下两个版本都是Http1.1的

## Http1.0

### 版本1

客户端请求某资源，服务器返回该资源，并在响应头加上字段：Expires:具体时间，例如：Expires:Thu,31 Dec 2020 23:59:59 GMT，表示该资源的过期时间

客户端收到该资源后，会把Expires字段也缓存下来，下次再请求相同资源时，会先取出上次请求到资源后缓存的Expires字段，再和客户端当下的时间进行对比，如果当下时间已经超过了过期时间，则重新发起请求，如果没到过期时间，则直接返回缓存（如果缓存还在的话）

优点就是不用再次发起请求询问服务器缓存是否有效，而缺点也是因为这个原因，完全依赖客户端的时间，那就可能会出现客户端时间不准确的情况，比如客户端修改了本地时间，这样就造成无法准确判断缓存过期时间了；另外服务器返回的Expire字段表示缓存的过期时间，而大多数情况，服务器也不知道资源啥时候过期。

所以，Http协议有了下面的改进：就是把决定缓存是否有效的权利从客户端移到了服务端

## Http1.1

### 版本2

为了解决上述问题，Http1.1新加了：
- Cache-Control：响应头字段，缓存策略，no-store(禁止缓存)、no-cache(这里并不是不可以缓存，而是可以缓存，但要先请求服务器验证缓存是否有效。不知道为啥起这个名字，太有误导性了，OkHttp的源码中也有类似说法，说no-cache is misleading)等等
- Last-Modify：响应头字段，表示资源最新的修改时间
- If-Modify-Since：请求头字段，表示资源如果自指定的时间以来修改过了，服务器就返回新资源，否则返回304状态码，客户端使用缓存即可

所以流程就变成了：
1. 客户端发起资源请求
2. 服务端下发资源，并在响应头中加入Cache-Control字段告知客户端该资源的缓存策略，以及Last-Modify字段告知该资源的最新修改时间
3. 客户端再次请求该资源时，在请求头中加上If-Modify-Since字段，并将上次返回资源时的响应头字段Last-Modify的时间值赋给If-Modify-Since字段
4. 这样服务端和当下资源最新修改时间对比下，就知道要不要返回资源数据了

这样，缓存是否有效的决定权就从客户端移到了服务器端

这个思路也是我们在开发类似新闻列表需求时，请求数据有没有更新的思路。


但这个是有问题的：
1. Last-Modify表示的最小粒度是秒，而如果一个资源在一秒内多次修改就无法表示了
2. 只能表示时间变化这一个维度，如果文件内容没变，只是更新了时间 就无法表示了

基于上述两个问题，就出现了第三个版本

### 版本3

Http1.1又更新了小版本来优化上述问题，新加入了ETag、If-None-Match头字段

- ETag：响应头字段，资源内容的唯一标识，相当于资源的信息摘要，内容变化ETag的值也会跟着变，这样解决了修改时间变化，但内容不变造成的缓存失效问题，节约了流量。格式是字符串，但要放在双引号中，例如：
```
ETag: "1ec5-502264e2ae4c0"
```
- If-None-Match: 请求头字段，该字段由客户端发起，带上上次返回资源时的ETag值，这样服务端就可以对比资源最新的ETag值，如果不一样就返回资源数据，否则不返回
- If-Match: 这个和If-None-Match正好相反，是一致返回资源，否则不返回。可以了解下，一般不用它

## 总结

Http的缓存机制，其实就是一些请求头和响应头的字段，理解并记忆即可。

- 版本一：Expires字段，表示资源的过期时间
- 版本二：Cache-Control（no-stroe、no-cache）、Last-Modify（资源上次的更新时间）、If-Modify-Since
- 版本三：E-Tag、If-None-Match