---
title: 序列化
description: 
slug: work-android-mosaic
date: 2022-03-28T04:14:54-08:00
categories:
    - Android
tags:
    - 序列化
---

## 什么是序列化

你可能张口就来：把对象转成二进制数据的过程。

回答的没错，但对象在内存中也是按照二进制格式存储的，也就是说把二进制转成了二进制，既然都是二进制为啥还要转呢？

所以，这个说法还是不够严谨。

其实，虽然转换前和转换后都是二进制数据，但表现出来的结果是不一样的，或者说二进制数据的组织规则是不一样的。

那序列化的本质是什么呢？回答这个问题，要从为什么要序列化讲起，而回答为什么要序列化，就要先了解序列化的场景有哪些，这样通过反向推导来得出序列化的本质。

下面我们一个个来讲。

## 序列化的场景

一共有三种场景：

1. 网络传输
2. 持久化到本地
3. 进程间通信

### 网络传输

网络分为有线网络和无线网络两种，我们来看下数据在有线网络和无线网络中是如何传播的。

- 有线网络分为电线和光纤。

电线是通过电压来控制信号，高电压表示1，低电压表示0，其材质是铜等金属，因为金属可以导电；

光纤是通过光来控制信号，强光表示1，弱光表示0，其材质是玻璃，因为玻璃可以折射光线。

- 无线网络

无线网络是通过无线电波控制控制信号的，这些信号又分为模拟信号和数字信号两种。

模拟信号是幅度随时间的变化而连续变化的信号；

数字信号是幅度随时间的变化而离散（跳跃）变化的信号；（需要强调的是，数字信号指的是二值信号，就是只有两种幅度的无线电信号，这样就可以用来表示0和1）

关键是理解连续和离散的区别，这里有个比喻方便记忆：

可以把模拟信号想象成手指在手机屏幕上滑动的过程（连续）；

可以把数字信号想象成手指在手机屏幕上点击的过程（离散）。

模拟信号的优点是能最大程度的还原真实信息，缺点是容易受到外界的干扰，并且无法加密；

数字信号的优点是不容易受到外界的干扰，并且可以加密，缺点是失真严重。

广播用的是模拟信号；

WIFI用的是数字信号；

所以，无论是有线网络还是无线网络，最终都是通过使用两种信号来传输二进制数据的。

### 持久化到本地

持久化到本地，这里的本地指的是计算机，因为CPU只能处理0和1，也就是二进制格式的数据。

所以，无论是视频、音频还是图片、文字等信息，最终都是以二进制数据的格式存储在计算机中的，包括CPU的高速缓存、主存内存条、硬盘等所有的存储设备。

### 进程间通信

涉及的知识点比较多，具体查看【IPC机制】章节。

直接说结论，进程间传递的数据也是该数据的二进制序列。

接下来就可以回答为什么要进行序列化了。

## 为什么要序列化

从上面序列化的场景来看，想将一个对象进行网络传输、持久化到本地、进程间通信，都需要先序列化成二进制序列，但对象在内存中本来就是二进制的格式，直接取出来进行传输不行吗？非得进行序列化才能传输？

答：不行。

有两个原因：

- 对象在内存中的二进制数据不是跨平台的

  因为对象在各个平台中的内存模型是不一样的，比如存储一个User对象，User对象有两个属性name和age，在Java平台和Python平台的内存模型中对User对象在内存中的组织规则大不相同，所以根本不可能从各自平台的内存中直接取出进行传输，这样传输过去的二进制序列，对方平台是不认的。

  所以，为什么要序列化，就和为什么要学习普通话一个道理。

- 对象在内存中的二进制数据不是连续的，不是一个整体，是分散的

  因为要进行传输，首先要放在一起，形成一个整体才能传输，就好比搬家前要先把东西都搬到车上然后一起出发，总不能放一件东西车就出发吧。

所以序列化就是把对象转化成一种跨平台识别的字节格式并打包到一块儿的过程，这样其他平台也能够解析并还原成对象。



## 序列化的本质

所以序列化的本质，就是将对象转化成【可传输】的字节序列的过程。

关键字是：可传输。

可传输有两个含义：跨平台和整体。

要达成跨平台，就要有一定的转换规则，这样序列化后才能反序列化成功。

要达成整体，就要打包到一块儿，这样才更容易传输。

以后有人问到序列化是什么？千万别回答序列化是将对象转化成二进制序列的过程，而要在二进制前面加上一个限定词：可传输，这样更严谨，也更专业。

## 序列化的方式

序列化的方式其实就是一种转换规则，常见的有：

- JSON
- XML
- Protobuff
- JDK等平台自有的序列化

## 注意事项

- static属性不会被序列化

  因为static修饰的属性属于类，不属于对象，而序列化是针对对象而言的，所以static属性不会被序列化。

- transient属性不会被序列化

  因为transient关键字是专门用在序列化中修饰对象中不想被序列化的属性的。

- serialVersionUID序列化版本号的使用

  就是用来标记序列化对象时的版本的，只有版本号一致，才能反序列化成功。

  即使属性没变，但序列化版本号不一样，反序列化也会失败；

  如果只是新增了属性，但序列化版本号没变，则反序列化可以成功，只是新增的属性获取不到而已。





