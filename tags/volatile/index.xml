<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Volatile on Num21</title><link>https://pangfq.github.io/blog/tags/volatile/</link><description>Recent content in Volatile on Num21</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Fri, 05 Feb 2021 18:55:20 -0800</lastBuildDate><atom:link href="https://pangfq.github.io/blog/tags/volatile/index.xml" rel="self" type="application/rss+xml"/><item><title>volatile关键字的作用</title><link>https://pangfq.github.io/blog/p/java-volatile/</link><pubDate>Fri, 05 Feb 2021 18:55:20 -0800</pubDate><guid>https://pangfq.github.io/blog/p/java-volatile/</guid><description>&lt;h2 id="概述">概述
&lt;/h2>&lt;p>volatile，Java中的关键字，用于修饰变量，中文表示不稳定的，易变的意思。&lt;/p>
&lt;h2 id="作用">作用
&lt;/h2>&lt;p>volatile有两个作用：&lt;/p>
&lt;ol>
&lt;li>保证并发编程下的内存可见性&lt;/li>
&lt;li>保证并发编程下的代码有序性，禁止指令重排优化&lt;/li>
&lt;/ol>
&lt;h3 id="保证并发编程下的程序可见性">保证并发编程下的程序可见性
&lt;/h3>&lt;p>可见性，表示一个线程修改了某个变量，则其他线程可以立即同步&lt;/p>
&lt;p>因为在多核CPU中，每个核心都有各自的高速缓存，分别是一级和二级，其实还有第三级，但第三级是共享的高速缓存&lt;/p>
&lt;p>CPU在进行运算的时候，先从一级缓存中取数据，没有再去二级缓存中，还没有则取三级缓存，如果三级缓存中也没有的话才会到主存中取&lt;/p>
&lt;p>对应的写操作同理，也是先写到高速缓存最后才同步到主存&lt;/p>
&lt;p>所以，在并发编程中就会出现数据不同步的问题，比如，在一个两核心的CPU中，线程A在核心a中运行，将初始值为0的变量i加1后更新到自己的高速缓存中，此时的变量i=1；线程B在核心b中运行，同样执行i+1操作，但由于主存中的变量i仍然是0，得到的i=1，所以这样就造成了并发编程下的可见性问题，其实就是数据不同步的问题&lt;/p>
&lt;p>被volatile修饰的变量表示每次读写都会到主存中，这样可以保证数据的可见性（一致性）&lt;/p>
&lt;h3 id="保证并发编程下的程序有序性禁止指令重排优化">保证并发编程下的程序有序性，禁止指令重排优化
&lt;/h3>&lt;p>什么是指令重排？&lt;/p>
&lt;p>计算机在执行程序时，为了最大化地提高CPU内部各种计算单元的利用率，常常对所要执行的指令（程序）做重排优化&lt;/p>
&lt;p>当然这个指令重排对于单线程不会有影响，但在多线程情况下会导致有序性的问题&lt;/p>
&lt;p>这个问题就是，在多线程编程情况下，可能会出现得到的实际对象为null的问题。&lt;/p>
&lt;p>比如：在double check写法的单例模式下，线程A执行了new操作，但由于指令重排的存在，可能会导致线程B在获取实例的时候该实例变量不为null，但实际指向的对象还未初始化的情况，造成线程B得到一个变量不为null，但实际指向的对象却是null的情况。&lt;/p>
&lt;h2 id="相关问题">相关问题
&lt;/h2>&lt;p>一个int变量用volatile修饰后能保证并发编程下的线程安全吗？&lt;/p>
&lt;p>答：不能。因为volatile可以实现并发编程下的两个特性，一个是可见性，一个是有序性，但无法实现操作的原子性，也就是如果这个操作不是原子性的，比如i++就无法保证并发编程下的线程安全。&lt;/p></description></item></channel></rss>