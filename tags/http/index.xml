<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>HTTP on Num21</title><link>https://pangfq.github.io/blog/tags/http/</link><description>Recent content in HTTP on Num21</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Mon, 01 Feb 2021 18:55:20 -0800</lastBuildDate><atom:link href="https://pangfq.github.io/blog/tags/http/index.xml" rel="self" type="application/rss+xml"/><item><title>HTTP的缓存机制</title><link>https://pangfq.github.io/blog/p/http-cache/</link><pubDate>Mon, 01 Feb 2021 18:55:20 -0800</pubDate><guid>https://pangfq.github.io/blog/p/http-cache/</guid><description>&lt;h2 id="概述">概述
&lt;/h2>&lt;p>Http协议的缓存策略，分为了三个版本，每个版本的策略都解决了上个版本出现的问题，所以从这方面来看，Http的缓存策略也不是说一出来就很完善，也是后面慢慢优化出来的。&lt;/p>
&lt;p>第一个版本在Http1.0时期，剩下两个版本都是Http1.1的&lt;/p>
&lt;h2 id="http10">Http1.0
&lt;/h2>&lt;h3 id="版本1">版本1
&lt;/h3>&lt;p>客户端请求某资源，服务器返回该资源，并在响应头加上字段：Expires:具体时间，例如：Expires:Thu,31 Dec 2020 23:59:59 GMT，表示该资源的过期时间&lt;/p>
&lt;p>客户端收到该资源后，会把Expires字段也缓存下来，下次再请求相同资源时，会先取出上次请求到资源后缓存的Expires字段，再和客户端当下的时间进行对比，如果当下时间已经超过了过期时间，则重新发起请求，如果没到过期时间，则直接返回缓存（如果缓存还在的话）&lt;/p>
&lt;p>优点就是不用再次发起请求询问服务器缓存是否有效，而缺点也是因为这个原因，完全依赖客户端的时间，那就可能会出现客户端时间不准确的情况，比如客户端修改了本地时间，这样就造成无法准确判断缓存过期时间了；另外服务器返回的Expire字段表示缓存的过期时间，而大多数情况，服务器也不知道资源啥时候过期。&lt;/p>
&lt;p>所以，Http协议有了下面的改进：就是把决定缓存是否有效的权利从客户端移到了服务端&lt;/p>
&lt;h2 id="http11">Http1.1
&lt;/h2>&lt;h3 id="版本2">版本2
&lt;/h3>&lt;p>为了解决上述问题，Http1.1新加了：&lt;/p>
&lt;ul>
&lt;li>Cache-Control：响应头字段，缓存策略，no-store(禁止缓存)、no-cache(这里并不是不可以缓存，而是可以缓存，但要先请求服务器验证缓存是否有效。不知道为啥起这个名字，太有误导性了，OkHttp的源码中也有类似说法，说no-cache is misleading)等等&lt;/li>
&lt;li>Last-Modify：响应头字段，表示资源最新的修改时间&lt;/li>
&lt;li>If-Modify-Since：请求头字段，表示资源如果自指定的时间以来修改过了，服务器就返回新资源，否则返回304状态码，客户端使用缓存即可&lt;/li>
&lt;/ul>
&lt;p>所以流程就变成了：&lt;/p>
&lt;ol>
&lt;li>客户端发起资源请求&lt;/li>
&lt;li>服务端下发资源，并在响应头中加入Cache-Control字段告知客户端该资源的缓存策略，以及Last-Modify字段告知该资源的最新修改时间&lt;/li>
&lt;li>客户端再次请求该资源时，在请求头中加上If-Modify-Since字段，并将上次返回资源时的响应头字段Last-Modify的时间值赋给If-Modify-Since字段&lt;/li>
&lt;li>这样服务端和当下资源最新修改时间对比下，就知道要不要返回资源数据了&lt;/li>
&lt;/ol>
&lt;p>这样，缓存是否有效的决定权就从客户端移到了服务器端&lt;/p>
&lt;p>这个思路也是我们在开发类似新闻列表需求时，请求数据有没有更新的思路。&lt;/p>
&lt;p>但这个是有问题的：&lt;/p>
&lt;ol>
&lt;li>Last-Modify表示的最小粒度是秒，而如果一个资源在一秒内多次修改就无法表示了&lt;/li>
&lt;li>只能表示时间变化这一个维度，如果文件内容没变，只是更新了时间 就无法表示了&lt;/li>
&lt;/ol>
&lt;p>基于上述两个问题，就出现了第三个版本&lt;/p>
&lt;h3 id="版本3">版本3
&lt;/h3>&lt;p>Http1.1又更新了小版本来优化上述问题，新加入了ETag、If-None-Match头字段&lt;/p>
&lt;ul>
&lt;li>ETag：响应头字段，资源内容的唯一标识，相当于资源的信息摘要，内容变化ETag的值也会跟着变，这样解决了修改时间变化，但内容不变造成的缓存失效问题，节约了流量。格式是字符串，但要放在双引号中，例如：&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">ETag: &amp;#34;1ec5-502264e2ae4c0&amp;#34;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;ul>
&lt;li>If-None-Match: 请求头字段，该字段由客户端发起，带上上次返回资源时的ETag值，这样服务端就可以对比资源最新的ETag值，如果不一样就返回资源数据，否则不返回&lt;/li>
&lt;li>If-Match: 这个和If-None-Match正好相反，是一致返回资源，否则不返回。可以了解下，一般不用它&lt;/li>
&lt;/ul>
&lt;h2 id="总结">总结
&lt;/h2>&lt;p>Http的缓存机制，其实就是一些请求头和响应头的字段，理解并记忆即可。&lt;/p>
&lt;ul>
&lt;li>版本一：Expires字段，表示资源的过期时间&lt;/li>
&lt;li>版本二：Cache-Control（no-stroe、no-cache）、Last-Modify（资源上次的更新时间）、If-Modify-Since&lt;/li>
&lt;li>版本三：E-Tag、If-None-Match&lt;/li>
&lt;/ul></description></item></channel></rss>